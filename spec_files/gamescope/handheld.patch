From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MithicSpirit <rpc01234@gmail.com>
Date: Sun, 22 Dec 2024 16:55:21 -0500
Subject: Consistent indentation

The codebase has lots of inconsistent indentation between 1 tab or 4
spaces. Rather than having massive diffs by fixing all that, this sets
the editorconfig tab width to 4, so it's at least visually consistent,
even on editors that default to 8-wide tabs.
---
 .editorconfig | 1 +
 1 file changed, 1 insertion(+)

diff --git a/.editorconfig b/.editorconfig
index 9b5abc1c8be9..dc59c756388f 100644
--- a/.editorconfig
+++ b/.editorconfig
@@ -5,3 +5,4 @@ end_of_line = lf
 insert_final_newline = true
 trim_trailing_whitespace = false
 indent_style = tab
+tab_width = 4
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Martin <spleefer90@gmail.com>
Date: Sat, 2 Nov 2024 15:58:26 +0100
Subject: README.md: Exclude end of life distributions in Repology status

---
 README.md | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/README.md b/README.md
index 831ec947d66a..5df4a2589084 100644
--- a/README.md
+++ b/README.md
@@ -88,4 +88,4 @@ Pull requests for improving Reshade compatibility support are appreciated.
 
 ## Status of Gamescope Packages
 
-[![Packaging status](https://repology.org/badge/vertical-allrepos/gamescope.svg)](https://repology.org/project/gamescope/versions)
+[![Packaging status](https://repology.org/badge/vertical-allrepos/gamescope.svg?exclude_unsupported=1)](https://repology.org/project/gamescope/versions)
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Ferdinand Bachmann <ferdinand.bachmann@yrlf.at>
Date: Mon, 14 Jul 2025 22:34:04 +0200
Subject: WaylandBackend: fix crash in UpdateCursor() when m_pPointer is null

This can happen when the seat loses pointer capability, such as when
switching to another TTY on Sway.
---
 src/Backends/WaylandBackend.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/Backends/WaylandBackend.cpp b/src/Backends/WaylandBackend.cpp
index 1171980ba61d..852c56618f73 100644
--- a/src/Backends/WaylandBackend.cpp
+++ b/src/Backends/WaylandBackend.cpp
@@ -2406,6 +2406,9 @@ namespace gamescope
     {
         bool bUseHostCursor = false;
 
+        if ( !m_pPointer )
+            return;
+
         if ( cv_wayland_mouse_warp_without_keyboard_focus )
             bUseHostCursor = m_pRelativePointer && !m_bKeyboardEntered && m_pDefaultCursorSurface;
         else
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Olivier Tilloy <otilloy@igalia.com>
Date: Fri, 22 Aug 2025 23:04:39 +0200
Subject: wlserver: associate a monitor to each touchscreen input device

and use its orientation to transform touch events.
When an external touchscreen is connected to a Steam Deck,
both the internal touchscreen and the external one can be used for touch input,
but they might have different orientations.

Fixes ValveSoftware/SteamOS#1259.
---
 src/wlserver.cpp | 56 ++++++++++++++++++++++++++++++++++++++++--------
 src/wlserver.hpp |  6 ++++--
 2 files changed, 51 insertions(+), 11 deletions(-)

diff --git a/src/wlserver.cpp b/src/wlserver.cpp
index 4d8546eed51f..60ea18e77076 100644
--- a/src/wlserver.cpp
+++ b/src/wlserver.cpp
@@ -414,12 +414,48 @@ static inline uint32_t TouchClickModeToLinuxButton( gamescope::TouchClickMode eT
 
 std::atomic<bool> g_bPendingTouchMovement = { false };
 
+static void wlserver_touch_associate_connector(struct wlserver_touch *touch)
+{
+	if (touch->connector != nullptr) return;
+
+	// Heuristic to associate a monitor to a touch input device:
+	//  - if a touchscreen's bus is IÂ²C, it can very likely be associated to an internal monitor.
+	//  - if its bus is USB, it can be associated to an external monitor.
+	// This isn't perfect, but we can't rely on the physical sizes reported by both devices,
+	// because it's not uncommon for touchscreens to report wildly incorrect sizes.
+	gamescope::IBackendConnector* connector = nullptr;
+	struct libinput_device *lidev = wlr_libinput_get_device_handle(&touch->wlr->base);
+	struct udev_device *dev = libinput_device_get_udev_device(lidev);
+	auto *parent = dev;
+	while (parent) {
+		const char *subsystem = udev_device_get_subsystem(parent);
+		if (subsystem) {
+			if (strcmp( subsystem, "i2c" ) == 0) {
+				connector = GetBackend()->GetConnector(gamescope::GAMESCOPE_SCREEN_TYPE_INTERNAL);
+				break;
+			} else if (strcmp( subsystem, "usb" ) == 0) {
+				connector = GetBackend()->GetConnector(gamescope::GAMESCOPE_SCREEN_TYPE_EXTERNAL);
+				break;
+			}
+		}
+		parent = udev_device_get_parent(parent);
+	}
+	udev_device_unref(dev);
+	if (connector != nullptr) {
+		touch->connector = connector;
+		wl_log.infof("associating connector %s (%s %s) with touch input device %s",
+			connector->GetName(), connector->GetMake(), connector->GetModel(),
+			libinput_device_get_name(lidev));
+	}
+}
+
 static void wlserver_handle_touch_down(struct wl_listener *listener, void *data)
 {
 	struct wlserver_touch *touch = wl_container_of( listener, touch, down );
 	struct wlr_touch_down_event *event = (struct wlr_touch_down_event *) data;
 
-	wlserver_touchdown( event->x, event->y, event->touch_id, event->time_msec );
+	wlserver_touch_associate_connector( touch );
+	wlserver_touchdown( event->x, event->y, event->touch_id, event->time_msec, touch->connector );
 }
 
 static void wlserver_handle_touch_up(struct wl_listener *listener, void *data)
@@ -435,7 +471,8 @@ static void wlserver_handle_touch_motion(struct wl_listener *listener, void *dat
 	struct wlserver_touch *touch = wl_container_of( listener, touch, motion );
 	struct wlr_touch_motion_event *event = (struct wlr_touch_motion_event *) data;
 
-	wlserver_touchmotion( event->x, event->y, event->touch_id, event->time_msec );
+	wlserver_touch_associate_connector( touch );
+	wlserver_touchmotion( event->x, event->y, event->touch_id, event->time_msec, false, touch->connector );
 }
 
 static void wlserver_new_input(struct wl_listener *listener, void *data)
@@ -491,6 +528,8 @@ static void wlserver_new_input(struct wl_listener *listener, void *data)
 			wl_signal_add( &touch->wlr->events.up, &touch->up );
 			touch->motion.notify = wlserver_handle_touch_motion;
 			wl_signal_add( &touch->wlr->events.motion, &touch->motion );
+
+			wlserver_touch_associate_connector( touch );
 		}
 		break;
 		default:
@@ -2740,13 +2779,12 @@ const std::shared_ptr<wlserver_vk_swapchain_feedback>& wlserver_surface_swapchai
 }
 
 /* Handle the orientation of the touch inputs */
-static void apply_touchscreen_orientation(double *x, double *y )
+static void apply_touchscreen_orientation(GamescopePanelOrientation orientation, double *x, double *y )
 {
 	double tx = 0;
 	double ty = 0;
 
-	// Use internal screen always for orientation purposes.
-	switch ( GetBackend()->GetConnector( gamescope::GAMESCOPE_SCREEN_TYPE_INTERNAL )->GetCurrentOrientation() )
+	switch ( orientation )
 	{
 		default:
 		case GAMESCOPE_PANEL_ORIENTATION_AUTO:
@@ -2772,7 +2810,7 @@ static void apply_touchscreen_orientation(double *x, double *y )
 	*y = ty;
 }
 
-void wlserver_touchmotion( double x, double y, int touch_id, uint32_t time, bool bAlwaysWarpCursor )
+void wlserver_touchmotion( double x, double y, int touch_id, uint32_t time, bool bAlwaysWarpCursor, gamescope::IBackendConnector* connector )
 {
 	assert( wlserver_is_lock_held() );
 
@@ -2781,7 +2819,7 @@ void wlserver_touchmotion( double x, double y, int touch_id, uint32_t time, bool
 		double tx = x;
 		double ty = y;
 
-		apply_touchscreen_orientation(&tx, &ty);
+		apply_touchscreen_orientation((connector ? connector : GetBackend()->GetCurrentConnector())->GetCurrentOrientation(), &tx, &ty);
 
 		tx *= g_nOutputWidth;
 		ty *= g_nOutputHeight;
@@ -2827,7 +2865,7 @@ void wlserver_touchmotion( double x, double y, int touch_id, uint32_t time, bool
 	bump_input_counter();
 }
 
-void wlserver_touchdown( double x, double y, int touch_id, uint32_t time )
+void wlserver_touchdown( double x, double y, int touch_id, uint32_t time, gamescope::IBackendConnector* connector )
 {
 	assert( wlserver_is_lock_held() );
 
@@ -2836,7 +2874,7 @@ void wlserver_touchdown( double x, double y, int touch_id, uint32_t time )
 		double tx = x;
 		double ty = y;
 
-		apply_touchscreen_orientation(&tx, &ty);
+		apply_touchscreen_orientation((connector ? connector : GetBackend()->GetCurrentConnector())->GetCurrentOrientation(), &tx, &ty);
 
 		tx *= g_nOutputWidth;
 		ty *= g_nOutputHeight;
diff --git a/src/wlserver.hpp b/src/wlserver.hpp
index dd9d7aa9e397..375211efeb6f 100644
--- a/src/wlserver.hpp
+++ b/src/wlserver.hpp
@@ -214,6 +214,8 @@ struct wlserver_touch {
 	struct wl_listener down;
 	struct wl_listener up;
 	struct wl_listener motion;
+
+    gamescope::IBackendConnector* connector;
 };
 
 void xwayland_surface_commit(struct wlr_surface *wlr_surface);
@@ -242,8 +244,8 @@ void wlserver_mousewarp( double x, double y, uint32_t time, bool bSynthetic );
 void wlserver_mousebutton( int button, bool press, uint32_t time );
 void wlserver_mousewheel( double x, double y, uint32_t time );
 
-void wlserver_touchmotion( double x, double y, int touch_id, uint32_t time, bool bAlwaysWarpCursor = false );
-void wlserver_touchdown( double x, double y, int touch_id, uint32_t time );
+void wlserver_touchmotion( double x, double y, int touch_id, uint32_t time, bool bAlwaysWarpCursor = false, gamescope::IBackendConnector* connector = nullptr );
+void wlserver_touchdown( double x, double y, int touch_id, uint32_t time, gamescope::IBackendConnector* connector = nullptr );
 void wlserver_touchup( int touch_id, uint32_t time );
 
 void wlserver_send_frame_done( struct wlr_surface *surf, const struct timespec *when );
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Simon Ser <contact@emersion.fr>
Date: Thu, 16 Oct 2025 19:33:09 +0200
Subject: build: drop variable name from subproject fallbacks

These projects use meson.override_dependency(), no need to specify
the variable for the dep (which is an internal subproject detail).
---
 src/meson.build | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/meson.build b/src/meson.build
index a3dfdabd7366..63eabb1cf377 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -27,14 +27,14 @@ avif_dep = dependency('libavif', version: '>=1.0.0', required: get_option('avif_
 wlroots_dep = dependency(
   'wlroots',
   version: ['>= 0.18.0', '< 0.19.0'],
-  fallback: ['wlroots', 'wlroots'],
+  fallback: 'wlroots',
   default_options: ['default_library=static', 'examples=false', 'xwayland=enabled', 'backends=libinput', 'renderers=[]', 'allocators=[]', 'session=enabled'],
 )
 
 displayinfo_dep = dependency(
   'libdisplay-info',
   version: ['>= 0.0.0', '< 0.3.0'],
-  fallback: ['libdisplay-info', 'di_dep'],
+  fallback: 'libdisplay-info',
   default_options: ['default_library=static'],
 )
 
@@ -133,7 +133,7 @@ if drm_dep.found()
   liftoff_dep = dependency(
     'libliftoff',
     version: ['>= 0.5.0', '< 0.6.0'],
-    fallback: ['libliftoff', 'liftoff'],
+    fallback: 'libliftoff',
     default_options: ['default_library=static'],
   )
 else
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Simon Ser <contact@emersion.fr>
Date: Thu, 16 Oct 2025 19:38:26 +0200
Subject: build: fix wlroots dependency missing version

---
 src/meson.build     | 2 +-
 subprojects/wlroots | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/meson.build b/src/meson.build
index 63eabb1cf377..2aca36aab256 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -25,7 +25,7 @@ sdl2_dep = dependency('SDL2', required: get_option('sdl2_backend'))
 avif_dep = dependency('libavif', version: '>=1.0.0', required: get_option('avif_screenshots'))
 
 wlroots_dep = dependency(
-  'wlroots',
+  'wlroots-0.18',
   version: ['>= 0.18.0', '< 0.19.0'],
   fallback: 'wlroots',
   default_options: ['default_library=static', 'examples=false', 'xwayland=enabled', 'backends=libinput', 'renderers=[]', 'allocators=[]', 'session=enabled'],
diff --git a/subprojects/wlroots b/subprojects/wlroots
index 54e844748029..a5c9826e6d7d 160000
--- a/subprojects/wlroots
+++ b/subprojects/wlroots
@@ -1 +1 @@
-Subproject commit 54e844748029d4874e14d0c086d50092c04c8899
+Subproject commit a5c9826e6d7d8b504b07d1c02425e6f62b020791
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Simon Ser <contact@emersion.fr>
Date: Thu, 16 Oct 2025 19:43:28 +0200
Subject: Fix wlroots submodule commit

---
 subprojects/wlroots | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/subprojects/wlroots b/subprojects/wlroots
index a5c9826e6d7d..54e844748029 160000
--- a/subprojects/wlroots
+++ b/subprojects/wlroots
@@ -1 +1 @@
-Subproject commit a5c9826e6d7d8b504b07d1c02425e6f62b020791
+Subproject commit 54e844748029d4874e14d0c086d50092c04c8899
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Simon Ser <contact@emersion.fr>
Date: Thu, 16 Oct 2025 19:46:34 +0200
Subject: build: add missing pixman and libudev deps

---
 src/meson.build | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/src/meson.build b/src/meson.build
index 2aca36aab256..3650cdb3f8bc 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -23,6 +23,8 @@ cap_dep = dependency('libcap', required: get_option('rt_cap'))
 epoll_dep = dependency('epoll-shim', required: false)
 sdl2_dep = dependency('SDL2', required: get_option('sdl2_backend'))
 avif_dep = dependency('libavif', version: '>=1.0.0', required: get_option('avif_screenshots'))
+pixman_dep = dependency('pixman-1')
+udev_dep = dependency('libudev')
 
 wlroots_dep = dependency(
   'wlroots-0.18',
@@ -197,7 +199,7 @@ gamescope_version = configure_file(
       xkbcommon, thread_dep, sdl2_dep, wlroots_dep,
       vulkan_dep, liftoff_dep, dep_xtst, dep_xmu, cap_dep, epoll_dep, pipewire_dep, librt_dep,
       stb_dep, displayinfo_dep, openvr_dep, dep_xcursor, avif_dep, dep_xi,
-      libdecor_dep, eis_dep, luajit_dep, libinput_dep, libsystemd_dep,
+      libdecor_dep, eis_dep, luajit_dep, libinput_dep, libsystemd_dep, pixman_dep, udev_dep,
     ],
     install: true,
     cpp_args: gamescope_cpp_args,
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Colin Kinloch <colin.kinloch@collabora.com>
Date: Thu, 16 Oct 2025 22:42:09 +0100
Subject: WaylandBackend: listen for locked pointer events

Ignore relative pointer motion and only hide the cursor when the locked
pointer is in a locked state.

This allows the cursor to continue to show when interacting with the
window decorations.

Signed-off-by: Colin Kinloch <colin.kinloch@collabora.com>
---
 src/Backends/WaylandBackend.cpp | 49 ++++++++++++++++++++++++---------
 1 file changed, 36 insertions(+), 13 deletions(-)

diff --git a/src/Backends/WaylandBackend.cpp b/src/Backends/WaylandBackend.cpp
index 852c56618f73..4c1942337ebb 100644
--- a/src/Backends/WaylandBackend.cpp
+++ b/src/Backends/WaylandBackend.cpp
@@ -724,6 +724,10 @@ namespace gamescope
         void Wayland_Keyboard_Leave( wl_keyboard *pKeyboard, uint32_t uSerial, wl_surface *pSurface );
         static const wl_keyboard_listener s_KeyboardListener;
 
+		void Wayland_LockedPointer_Locked( zwp_locked_pointer_v1 *pLockedPointer );
+		void Wayland_LockedPointer_Unlocked( zwp_locked_pointer_v1 *pLockedPointer );
+		static const zwp_locked_pointer_v1_listener s_LockedPointerListener;
+
         void Wayland_WPColorManager_SupportedIntent( wp_color_manager_v1 *pWPColorManager, uint32_t uRenderIntent );
         void Wayland_WPColorManager_SupportedFeature( wp_color_manager_v1 *pWPColorManager, uint32_t uFeature );
         void Wayland_WPColorManager_SupportedTFNamed( wp_color_manager_v1 *pWPColorManager, uint32_t uTF );
@@ -792,6 +796,7 @@ namespace gamescope
         wl_pointer *m_pPointer = nullptr;
         wl_touch *m_pTouch = nullptr;
         zwp_locked_pointer_v1 *m_pLockedPointer = nullptr;
+		bool m_bPointerLocked = false;
         wl_surface *m_pLockedSurface = nullptr;
         zwp_relative_pointer_v1 *m_pRelativePointer = nullptr;
 
@@ -850,6 +855,11 @@ namespace gamescope
         .modifiers     = WAYLAND_NULL(),
         .repeat_info   = WAYLAND_NULL(),
     };
+	const zwp_locked_pointer_v1_listener CWaylandBackend::s_LockedPointerListener =
+	{
+		.locked        = WAYLAND_USERDATA_TO_THIS( CWaylandBackend, Wayland_LockedPointer_Locked ),
+		.unlocked      = WAYLAND_USERDATA_TO_THIS( CWaylandBackend, Wayland_LockedPointer_Unlocked ),
+	};
 
     const wp_color_manager_v1_listener CWaylandBackend::s_WPColorManagerListener
     {
@@ -2390,11 +2400,13 @@ namespace gamescope
                 m_pRelativePointer = nullptr;
             }
 
-            if ( bRelative )
-            {
-                m_pLockedPointer = zwp_pointer_constraints_v1_lock_pointer( m_pPointerConstraints, pSurface, m_pPointer, nullptr, ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_PERSISTENT );
-                m_pRelativePointer = zwp_relative_pointer_manager_v1_get_relative_pointer( m_pRelativePointerManager, m_pPointer );
-            }
+			if ( bRelative )
+			{
+				m_pLockedPointer = zwp_pointer_constraints_v1_lock_pointer( m_pPointerConstraints, pSurface, m_pPointer, nullptr, ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_PERSISTENT );
+				zwp_locked_pointer_v1_add_listener( m_pLockedPointer, &s_LockedPointerListener, this );
+
+				m_pRelativePointer = zwp_relative_pointer_manager_v1_get_relative_pointer( m_pRelativePointerManager, m_pPointer );
+			}
 
             m_InputThread.SetRelativePointer( bRelative );
 
@@ -2409,10 +2421,10 @@ namespace gamescope
         if ( !m_pPointer )
             return;
 
-        if ( cv_wayland_mouse_warp_without_keyboard_focus )
-            bUseHostCursor = m_pRelativePointer && !m_bKeyboardEntered && m_pDefaultCursorSurface;
-        else
-            bUseHostCursor = !m_bKeyboardEntered && m_pDefaultCursorSurface;
+		if ( cv_wayland_mouse_warp_without_keyboard_focus )
+			bUseHostCursor = m_bPointerLocked && !m_bKeyboardEntered && m_pDefaultCursorSurface;
+		else
+			bUseHostCursor = !m_bKeyboardEntered && m_pDefaultCursorSurface;
 
         if ( bUseHostCursor )
         {
@@ -2420,7 +2432,7 @@ namespace gamescope
         }
         else
         {
-            bool bHideCursor = m_pLockedPointer || !m_pCursorSurface;
+			bool bHideCursor = m_bPointerLocked || !m_pCursorSurface;
 
             if ( bHideCursor )
                 wl_pointer_set_cursor( m_pPointer, m_uPointerEnterSerial, nullptr, 0, 0 );
@@ -2645,6 +2657,17 @@ namespace gamescope
         UpdateCursor();
     }
 
+	void CWaylandBackend::Wayland_LockedPointer_Locked( zwp_locked_pointer_v1 *pLockedPointer )
+	{
+		m_bPointerLocked = true;
+		UpdateCursor();
+	}
+	void CWaylandBackend::Wayland_LockedPointer_Unlocked( zwp_locked_pointer_v1 *pLockedPointer )
+	{
+		m_bPointerLocked = false;
+		UpdateCursor();
+	}
+
     // WP Color Manager
 
     void CWaylandBackend::Wayland_WPColorManager_SupportedIntent( wp_color_manager_v1 *pWPColorManager, uint32_t uRenderIntent )
@@ -3191,9 +3214,9 @@ namespace gamescope
 
     void CWaylandInputThread::Wayland_RelativePointer_RelativeMotion( zwp_relative_pointer_v1 *pRelativePointer, uint32_t uTimeHi, uint32_t uTimeLo, wl_fixed_t fDx, wl_fixed_t fDy, wl_fixed_t fDxUnaccel, wl_fixed_t fDyUnaccel )
     {
-        // Don't do any motion/movement stuff if we don't have kb focus
-        if ( !cv_wayland_mouse_relmotion_without_keyboard_focus && !m_bKeyboardEntered )
-            return;
+		// Don't do any motion/movement stuff if we don't have kb focus
+		if ( !m_pBackend->m_bPointerLocked || ( !cv_wayland_mouse_relmotion_without_keyboard_focus && !m_bKeyboardEntered ) )
+			return;
 
         wlserver_lock();
         wlserver_mousemotion( wl_fixed_to_double( fDxUnaccel ), wl_fixed_to_double( fDyUnaccel ), ++m_uFakeTimestamp );
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Colin Kinloch <colin.kinloch@collabora.com>
Date: Thu, 16 Oct 2025 21:34:24 +0100
Subject: WaylandBackend: disable input on overlay planes

Call `wl_surface_set_input_region` with an unmodified region to make
subsurfaces ignore input. This allows the toplevel planes to recieve
pointer and keyboard events directly even when overlay planes are
covering it.

Fixes #1466. Where pointer locking would never be triggered as the
pointer would only enter the mangohud plane rather than the toplevel
plane that had pointer locking enabled.

Signed-off-by: Colin Kinloch <colin.kinloch@collabora.com>
---
 src/Backends/WaylandBackend.cpp | 137 ++++++++++++++++++++------------
 1 file changed, 86 insertions(+), 51 deletions(-)

diff --git a/src/Backends/WaylandBackend.cpp b/src/Backends/WaylandBackend.cpp
index 4c1942337ebb..b8d1b32ffe1b 100644
--- a/src/Backends/WaylandBackend.cpp
+++ b/src/Backends/WaylandBackend.cpp
@@ -56,7 +56,9 @@ using namespace std::literals;
 
 static LogScope xdg_log( "xdg_backend" );
 
+static const char *GAMESCOPE_proxy_tag = "gamescope-proxy";
 static const char *GAMESCOPE_plane_tag = "gamescope-plane";
+static const char *GAMESCOPE_toplevel_tag = "gamescope-toplevel";
 
 template <typename Func, typename... Args>
 auto CallWithAllButLast(Func pFunc, Args&&... args)
@@ -75,10 +77,34 @@ static inline uint32_t WaylandScaleToLogical( uint32_t pValue, uint32_t pFactor
     return div_roundup( pValue * WL_FRACTIONAL_SCALE_DENOMINATOR, pFactor );
 }
 
-static bool IsSurfacePlane( wl_surface *pSurface ) {
-    // HACK: this probably should never be called with a null pointer, but it
-    // was happening after a window was closed.
-    return pSurface && (wl_proxy_get_tag( (wl_proxy *)pSurface ) == &GAMESCOPE_plane_tag);
+[[maybe_unused]] static bool IsGamescopeProxy( void *pProxy ) {
+	// HACK: this probably should never be called with a null pointer, but it
+	// was happening after a window was closed.
+	if ( pProxy )
+		return false;
+
+	const char* const* pTag = wl_proxy_get_tag( (wl_proxy *)pProxy );
+
+	return pTag == &GAMESCOPE_proxy_tag ||
+		pTag == &GAMESCOPE_plane_tag ||
+		pTag == &GAMESCOPE_toplevel_tag;
+}
+
+[[maybe_unused]] static bool IsGamescopePlane( wl_surface *pSurface ) {
+	// HACK: this probably should never be called with a null pointer, but it
+	// was happening after a window was closed.
+	if ( pSurface )
+		return false;
+	const char* const* pTag = wl_proxy_get_tag( (wl_proxy *)pSurface );
+
+	return pTag == &GAMESCOPE_plane_tag ||
+		pTag == &GAMESCOPE_toplevel_tag;
+}
+
+static bool IsGamescopeToplevel( wl_surface *pSurface ) {
+	// HACK: this probably should never be called with a null pointer, but it
+	// was happening after a window was closed.
+	return pSurface && (wl_proxy_get_tag( (wl_proxy *)pSurface ) == &GAMESCOPE_toplevel_tag);
 }
 
 #define WAYLAND_NULL() []<typename... Args> ( void *pData, Args... args ) { }
@@ -527,7 +553,7 @@ namespace gamescope
         double m_flScrollAccum[2] = { 0.0, 0.0 };
         uint32_t m_uAxisSource = WL_POINTER_AXIS_SOURCE_WHEEL;
 
-        CWaylandPlane *m_pCurrentCursorPlane = nullptr;
+		wl_surface *m_pCurrentCursorSurface = nullptr;
 
         std::optional<wl_fixed_t> m_ofPendingCursorX;
         std::optional<wl_fixed_t> m_ofPendingCursorY;
@@ -690,6 +716,7 @@ namespace gamescope
             return &iter->second;
         }
 
+		wl_region *GetEmptyRegion() const { return m_pEmptyRegion; }
         wl_region *GetFullRegion() const { return m_pFullRegion; }
         CWaylandFb *GetBlackFb() const { return m_BlackFb.get(); }
 
@@ -753,6 +780,7 @@ namespace gamescope
         zwp_linux_dmabuf_v1 *m_pLinuxDmabuf = nullptr;
         xdg_wm_base *m_pXdgWmBase = nullptr;
         wp_viewporter *m_pViewporter = nullptr;
+		wl_region *m_pEmptyRegion = nullptr;
         wl_region *m_pFullRegion = nullptr;
         Rc<CWaylandFb> m_BlackFb;
         OwningRc<CWaylandFb> m_pOwnedBlackFb;
@@ -1336,7 +1364,6 @@ namespace gamescope
     {
         m_pParent = pParent;
         m_pSurface = wl_compositor_create_surface( m_pBackend->GetCompositor() );
-        wl_proxy_set_tag( (wl_proxy *)m_pSurface, &GAMESCOPE_plane_tag );
         wl_surface_set_user_data( m_pSurface, this );
         wl_surface_add_listener( m_pSurface, &s_SurfaceListener, this );
 
@@ -1372,6 +1399,7 @@ namespace gamescope
 
         if ( !pParent )
         {
+			wl_proxy_set_tag( (wl_proxy *)m_pSurface, &GAMESCOPE_toplevel_tag );
             m_pFrame = libdecor_decorate( m_pBackend->GetLibDecor(), m_pSurface, &s_LibDecorFrameInterface, this );
             libdecor_frame_set_title( m_pFrame, "Gamescope" );
             libdecor_frame_set_app_id( m_pFrame, "gamescope" );
@@ -1379,9 +1407,12 @@ namespace gamescope
         }
         else
         {
+			wl_proxy_set_tag( (wl_proxy *)m_pSurface, &GAMESCOPE_plane_tag );
             m_pSubsurface = wl_subcompositor_get_subsurface( m_pBackend->GetSubcompositor(), m_pSurface, pParent->GetSurface() );
             wl_subsurface_place_above( m_pSubsurface, pSiblingBelow->GetSurface() );
             wl_subsurface_set_sync( m_pSubsurface );
+			// Allow pParent to receive input while covered by subsurface planes
+			wl_surface_set_input_region( m_pSurface, m_pBackend->GetEmptyRegion() );
         }
 
         wl_surface_commit( m_pSurface );
@@ -1654,8 +1685,8 @@ namespace gamescope
 
     void CWaylandPlane::Wayland_Surface_Enter( wl_surface *pSurface, wl_output *pOutput )
     {
-        if ( !IsSurfacePlane( pSurface ) )
-            return;
+		if ( !IsGamescopeToplevel( pSurface ) )
+			return;
 
         m_pOutputs.emplace_back( pOutput );
 
@@ -1663,8 +1694,8 @@ namespace gamescope
     }
     void CWaylandPlane::Wayland_Surface_Leave( wl_surface *pSurface, wl_output *pOutput )
     {
-        if ( !IsSurfacePlane( pSurface ) )
-            return;
+		if ( !IsGamescopeToplevel( pSurface ) )
+			return;
 
         std::erase( m_pOutputs, pOutput );
 
@@ -1979,6 +2010,10 @@ namespace gamescope
             return false;
         }
 
+		m_pEmptyRegion = wl_compositor_create_region( m_pCompositor );
+		m_pFullRegion = wl_compositor_create_region( m_pCompositor );
+		wl_region_add( m_pFullRegion, 0, 0, INT32_MAX, INT32_MAX );
+
         // Grab stuff from any extra bindings/listeners we set up, eg. format/modifiers.
         wl_display_roundtrip( m_pDisplay );
 
@@ -2064,9 +2099,6 @@ namespace gamescope
 
     bool CWaylandBackend::PostInit()
     {
-        m_pFullRegion = wl_compositor_create_region( m_pCompositor );
-        wl_region_add( m_pFullRegion, 0, 0, INT32_MAX, INT32_MAX );
-
         if ( m_pSinglePixelBufferManager )
         {
             wl_buffer *pBlackBuffer = wp_single_pixel_buffer_manager_v1_create_u32_rgba_buffer( m_pSinglePixelBufferManager, 0, 0, 0, ~0u );
@@ -2619,8 +2651,8 @@ namespace gamescope
 
     void CWaylandBackend::Wayland_Pointer_Enter( wl_pointer *pPointer, uint32_t uSerial, wl_surface *pSurface, wl_fixed_t fSurfaceX, wl_fixed_t fSurfaceY )
     {
-        if ( !IsSurfacePlane( pSurface ) )
-            return;
+		if ( !IsGamescopeToplevel( pSurface ) )
+			return;
 
         m_uPointerEnterSerial = uSerial;
         m_bMouseEntered = true;
@@ -2629,8 +2661,8 @@ namespace gamescope
     }
     void CWaylandBackend::Wayland_Pointer_Leave( wl_pointer *pPointer, uint32_t uSerial, wl_surface *pSurface )
     {
-        if ( !IsSurfacePlane( pSurface ) )
-            return;
+		if ( !IsGamescopeToplevel( pSurface ) )
+			return;
 
         m_bMouseEntered = false;
     }
@@ -2639,8 +2671,8 @@ namespace gamescope
 
     void CWaylandBackend::Wayland_Keyboard_Enter( wl_keyboard *pKeyboard, uint32_t uSerial, wl_surface *pSurface, wl_array *pKeys )
     {
-        if ( !IsSurfacePlane( pSurface ) )
-            return;
+		if ( !IsGamescopeToplevel( pSurface ) )
+			return;
 
         m_uKeyboardEnterSerial = uSerial;
         m_bKeyboardEntered = true;
@@ -2649,8 +2681,8 @@ namespace gamescope
     }
     void CWaylandBackend::Wayland_Keyboard_Leave( wl_keyboard *pKeyboard, uint32_t uSerial, wl_surface *pSurface )
     {
-        if ( !IsSurfacePlane( pSurface ) )
-            return;
+		if ( !IsGamescopeToplevel( pSurface ) )
+			return;
 
         m_bKeyboardEntered = false;
 
@@ -3009,35 +3041,35 @@ namespace gamescope
 
     // Pointer
 
-    void CWaylandInputThread::Wayland_Pointer_Enter( wl_pointer *pPointer, uint32_t uSerial, wl_surface *pSurface, wl_fixed_t fSurfaceX, wl_fixed_t fSurfaceY )
-    {
-        if ( !IsSurfacePlane( pSurface ) )
-            return;
+	void CWaylandInputThread::Wayland_Pointer_Enter( wl_pointer *pPointer, uint32_t uSerial, wl_surface *pSurface, wl_fixed_t fSurfaceX, wl_fixed_t fSurfaceY )
+	{
+		if ( !IsGamescopeToplevel( pSurface ) )
+			return;
 
-        CWaylandPlane *pPlane = (CWaylandPlane *)wl_surface_get_user_data( pSurface );
-        if ( !pPlane )
-            return;
-        m_pCurrentCursorPlane = pPlane;
-        m_bMouseEntered = true;
-        m_uPointerEnterSerial = uSerial;
+		m_pCurrentCursorSurface = pSurface;
+		m_bMouseEntered = true;
+		m_uPointerEnterSerial = uSerial;
 
-        Wayland_Pointer_Motion( pPointer, 0, fSurfaceX, fSurfaceY );
-    }
-    void CWaylandInputThread::Wayland_Pointer_Leave( wl_pointer *pPointer, uint32_t uSerial, wl_surface *pSurface )
-    {
-        if ( !IsSurfacePlane( pSurface ) )
-            return;
+		Wayland_Pointer_Motion( pPointer, 0, fSurfaceX, fSurfaceY );
+	}
+	void CWaylandInputThread::Wayland_Pointer_Leave( wl_pointer *pPointer, uint32_t uSerial, wl_surface *pSurface )
+	{
+		if ( !IsGamescopeToplevel( pSurface ) )
+			return;
+
+		m_pCurrentCursorSurface = nullptr;
+		m_bMouseEntered = false;
+	}
+	void CWaylandInputThread::Wayland_Pointer_Motion( wl_pointer *pPointer, uint32_t uTime, wl_fixed_t fSurfaceX, wl_fixed_t fSurfaceY )
+	{
+		if ( !m_bMouseEntered )
+			return;
+
+		CWaylandPlane *pPlane = (CWaylandPlane *)wl_surface_get_user_data( m_pCurrentCursorSurface );
+
+		if ( !pPlane )
+			return;
 
-        CWaylandPlane *pPlane = (CWaylandPlane *)wl_surface_get_user_data( pSurface );
-        if ( !pPlane )
-            return;
-        if ( pPlane != m_pCurrentCursorPlane )
-            return;
-        m_pCurrentCursorPlane = nullptr;
-        m_bMouseEntered = false;
-    }
-    void CWaylandInputThread::Wayland_Pointer_Motion( wl_pointer *pPointer, uint32_t uTime, wl_fixed_t fSurfaceX, wl_fixed_t fSurfaceY )
-    {
         if ( m_pRelativePointer.load() != nullptr )
             return;
 
@@ -3049,10 +3081,7 @@ namespace gamescope
             return;
         }
 
-        if ( !m_pCurrentCursorPlane )
-            return;
-
-        auto oState = m_pCurrentCursorPlane->GetCurrentState();
+		auto oState = pPlane->GetCurrentState();
         if ( !oState )
             return;
 
@@ -3154,6 +3183,9 @@ namespace gamescope
     }
     void CWaylandInputThread::Wayland_Keyboard_Enter( wl_keyboard *pKeyboard, uint32_t uSerial, wl_surface *pSurface, wl_array *pKeys )
     {
+		if ( !IsGamescopeToplevel( pSurface ) )
+			return;
+
         m_bKeyboardEntered = true;
         m_uScancodesHeld.clear();
 
@@ -3177,6 +3209,9 @@ namespace gamescope
     }
     void CWaylandInputThread::Wayland_Keyboard_Leave( wl_keyboard *pKeyboard, uint32_t uSerial, wl_surface *pSurface )
     {
+		if ( !IsGamescopeToplevel( pSurface ) )
+			return;
+
         m_bKeyboardEntered = false;
         m_uKeyModifiers = 0;
 
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Luke Jones <luke@ljones.dev>
Date: Sun, 27 Apr 2025 14:55:35 +1200
Subject: Add display script for Zotac Zone

Signed-off-by: Luke Jones <luke@ljones.dev>
---
 .../00-gamescope/displays/zotac.zone.oled.lua | 56 +++++++++++++++++++
 1 file changed, 56 insertions(+)
 create mode 100644 scripts/00-gamescope/displays/zotac.zone.oled.lua

diff --git a/scripts/00-gamescope/displays/zotac.zone.oled.lua b/scripts/00-gamescope/displays/zotac.zone.oled.lua
new file mode 100644
index 000000000000..8ea1392c14bf
--- /dev/null
+++ b/scripts/00-gamescope/displays/zotac.zone.oled.lua
@@ -0,0 +1,56 @@
+-- colorimetry from DXQ7D0023 PDF specification
+local zotac_amoled_colorimetry = {
+   r = { x = 0.6396, y = 0.3300 },
+   g = { x = 0.2998, y = 0.5996 },
+   b = { x = 0.1503, y = 0.0595 },
+   w = { x = 0.3095, y = 0.3095 }
+}
+
+gamescope.config.known_displays.zotac_amoled = {
+    pretty_name = "DXQ7D0023 AMOLED",
+    dynamic_refresh_rates = {
+        60, 72, 90, 120, 144
+    },
+    hdr = {
+        supported = true,
+        force_enabled = true,
+        eotf = gamescope.eotf.gamma22,
+        max_content_light_level = 993,
+        max_frame_average_luminance = 400,
+        min_content_light_level = 0.007
+    },
+    colorimetry = zotac_amoled_colorimetry,
+    dynamic_modegen = function(base_mode, refresh)
+        debug("Generating mode "..refresh.."Hz for DXQ7D0023 AMOLED")
+        local mode = base_mode
+
+        gamescope.modegen.set_resolution(mode, 1080, 1920)
+
+        -- Horizontal timings from PDF:       HFP, HSync, HBP
+        gamescope.modegen.set_h_timings(mode, 80, 44, 156)
+        -- Vertical timings from PDF: VFP=20, VSync=1, VBP=15
+        gamescope.modegen.set_v_timings(mode, 48, 2, 14)
+
+        mode.clock = gamescope.modegen.calc_max_clock(mode, refresh)
+        mode.vrefresh = gamescope.modegen.calc_vrefresh(mode)
+
+        return mode
+    end,
+    matches = function(display)
+        -- Match based on the EDID information
+        local lcd_types = {
+            { vendor = "ZDZ", model = "ZDZ0501" },
+            { vendor = "DXQ", model = "DXQ7D0023" },
+        }
+
+        for index, value in ipairs(lcd_types) do
+            if value.vendor == display.vendor and value.model == display.model then
+                debug("[zotac_amoled] Matched vendor: "..value.vendor.." model: "..value.model)
+                return 5000
+            end
+        end
+
+        return -1
+    end
+}
+debug("Registered DXQ7D0023 AMOLED as a known display")
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Philip Mueller <philm@manjaro.org>
Date: Mon, 20 Oct 2025 04:02:54 +0200
Subject: =?UTF-8?q?Adjust=20display=20script=20for=20Zotac=20Zone=0A-=2012?=
 =?UTF-8?q?0Hz=20is=20the=20official=20max=20supported=20refresh=20rate?=

---
 scripts/00-gamescope/displays/zotac.zone.oled.lua | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/scripts/00-gamescope/displays/zotac.zone.oled.lua b/scripts/00-gamescope/displays/zotac.zone.oled.lua
index 8ea1392c14bf..f800fc7eee6f 100644
--- a/scripts/00-gamescope/displays/zotac.zone.oled.lua
+++ b/scripts/00-gamescope/displays/zotac.zone.oled.lua
@@ -9,7 +9,7 @@ local zotac_amoled_colorimetry = {
 gamescope.config.known_displays.zotac_amoled = {
     pretty_name = "DXQ7D0023 AMOLED",
     dynamic_refresh_rates = {
-        60, 72, 90, 120, 144
+        60, 72, 90, 120
     },
     hdr = {
         supported = true,
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Xaver Hugl <xaver.hugl@kde.org>
Date: Sat, 25 Oct 2025 23:23:28 +0200
Subject: WaylandBackend: use luminance instead of transfer function for HDR
 check

HDR doesn't depend on PQ or any specific transfer function.
---
 src/Backends/WaylandBackend.cpp | 43 ++++++++++-----------------------
 1 file changed, 13 insertions(+), 30 deletions(-)

diff --git a/src/Backends/WaylandBackend.cpp b/src/Backends/WaylandBackend.cpp
index b8d1b32ffe1b..f9f7d254860f 100644
--- a/src/Backends/WaylandBackend.cpp
+++ b/src/Backends/WaylandBackend.cpp
@@ -460,6 +460,8 @@ namespace gamescope
         friend CWaylandPlane;
 
         BackendConnectorHDRInfo m_HDRInfo{};
+        uint32_t m_uReferenceLuminance = 203;
+        uint32_t m_uMaxTargetLuminance = 203;
         displaycolorimetry_t m_DisplayColorimetry = displaycolorimetry_709;
         std::vector<uint8_t> m_FakeEdid;
 
@@ -1840,7 +1842,16 @@ namespace gamescope
 
     void CWaylandPlane::Wayland_WPImageDescriptionInfo_Done( wp_image_description_info_v1 *pImageDescInfo )
     {
+        auto *pHDRInfo = &m_pConnector->m_HDRInfo;
+        if (m_pBackend->SupportsColorManagement()) {
+            pHDRInfo->bExposeHDRSupport   = ( cv_hdr_enabled && m_pConnector->m_uMaxTargetLuminance > m_pConnector->m_uReferenceLuminance );
+            pHDRInfo->eOutputEncodingEOTF = pHDRInfo->bExposeHDRSupport ? EOTF_PQ : EOTF_Gamma22;
+        }
 
+        xdg_log.infof( "HDR INFO" );
+        xdg_log.infof( "  cv_hdr_enabled: %s", cv_hdr_enabled ? "true" : "false" );
+        xdg_log.infof( "  uMaxLum: %u, uRefLum: %u", m_pConnector->m_uMaxTargetLuminance, m_pConnector->m_uReferenceLuminance);
+        xdg_log.infof( "  bExposeHDRSupport: %s", pHDRInfo->bExposeHDRSupport ? "true" : "false" );
     }
     void CWaylandPlane::Wayland_WPImageDescriptionInfo_ICCFile( wp_image_description_info_v1 *pImageDescInfo, int32_t nICCFd, uint32_t uICCSize )
     {
@@ -1858,41 +1869,13 @@ namespace gamescope
     void CWaylandPlane::Wayland_WPImageDescriptionInfo_TFPower( wp_image_description_info_v1 *pImageDescInfo, uint32_t uExp)
     {
 
-    }
-    static const char *TFToString( uint32_t uTF )
-    {
-        switch ( (wp_color_manager_v1_transfer_function) uTF )
-        {
-            case WP_COLOR_MANAGER_V1_TRANSFER_FUNCTION_BT1886: return "BT1886";
-            case WP_COLOR_MANAGER_V1_TRANSFER_FUNCTION_GAMMA22: return "GAMMA22";
-            case WP_COLOR_MANAGER_V1_TRANSFER_FUNCTION_GAMMA28: return "GAMMA28";
-            case WP_COLOR_MANAGER_V1_TRANSFER_FUNCTION_ST240: return "ST240";
-            case WP_COLOR_MANAGER_V1_TRANSFER_FUNCTION_EXT_LINEAR: return "EXT_LINEAR";
-            case WP_COLOR_MANAGER_V1_TRANSFER_FUNCTION_LOG_100: return "LOG_100";
-            case WP_COLOR_MANAGER_V1_TRANSFER_FUNCTION_LOG_316: return "LOG_316";
-            case WP_COLOR_MANAGER_V1_TRANSFER_FUNCTION_XVYCC: return "XVYCC";
-            case WP_COLOR_MANAGER_V1_TRANSFER_FUNCTION_SRGB: return "SRGB";
-            case WP_COLOR_MANAGER_V1_TRANSFER_FUNCTION_EXT_SRGB: return "EXT_SRGB";
-            case WP_COLOR_MANAGER_V1_TRANSFER_FUNCTION_ST2084_PQ: return "ST2084_PQ";
-            case WP_COLOR_MANAGER_V1_TRANSFER_FUNCTION_ST428: return "ST428";
-            case WP_COLOR_MANAGER_V1_TRANSFER_FUNCTION_HLG: return "HLG";
-            default: return "Unknown";
-        }
     }
     void CWaylandPlane::Wayland_WPImageDescriptionInfo_TFNamed( wp_image_description_info_v1 *pImageDescInfo, uint32_t uTF)
     {
-        auto *pHDRInfo = &m_pConnector->m_HDRInfo;
-        pHDRInfo->bExposeHDRSupport   = ( cv_hdr_enabled && uTF == WP_COLOR_MANAGER_V1_TRANSFER_FUNCTION_ST2084_PQ );
-        pHDRInfo->eOutputEncodingEOTF = ( cv_hdr_enabled && uTF == WP_COLOR_MANAGER_V1_TRANSFER_FUNCTION_ST2084_PQ ) ? EOTF_PQ : EOTF_Gamma22;
-
-        xdg_log.infof( "HDR INFO" );
-        xdg_log.infof( "  cv_hdr_enabled: %s", cv_hdr_enabled ? "true" : "false" );
-        xdg_log.infof( "  uTF: %s", TFToString( uTF ) );
-        xdg_log.infof( "  bExposeHDRSupport: %s", pHDRInfo->bExposeHDRSupport ? "true" : "false" );
     }
     void CWaylandPlane::Wayland_WPImageDescriptionInfo_Luminances( wp_image_description_info_v1 *pImageDescInfo, uint32_t uMinLum, uint32_t uMaxLum, uint32_t uRefLum )
     {
-
+        m_pConnector->m_uReferenceLuminance = uRefLum;
     }
     void CWaylandPlane::Wayland_WPImageDescriptionInfo_TargetPrimaries( wp_image_description_info_v1 *pImageDescInfo, int32_t nRedX, int32_t nRedY, int32_t nGreenX, int32_t nGreenY, int32_t nBlueX, int32_t nBlueY, int32_t nWhiteX, int32_t nWhiteY )
     {
@@ -1904,7 +1887,7 @@ namespace gamescope
     }
     void CWaylandPlane::Wayland_WPImageDescriptionInfo_TargetLuminance( wp_image_description_info_v1 *pImageDescInfo, uint32_t uMinLum, uint32_t uMaxLum )
     {
-
+        m_pConnector->m_uMaxTargetLuminance = uMaxLum;
     }
     void CWaylandPlane::Wayland_WPImageDescriptionInfo_Target_MaxCLL( wp_image_description_info_v1 *pImageDescInfo, uint32_t uMaxCLL )
     {
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Anna Maniscalco <anna.maniscalco2000@gmail.com>
Date: Fri, 31 Oct 2025 00:50:45 +0100
Subject: steamcompmgr: pick focused pid consistently with engine

Pick focusedWindow_pid the same way as focusedWindow_engine which has
proven more reliable.
---
 src/steamcompmgr.cpp | 9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

diff --git a/src/steamcompmgr.cpp b/src/steamcompmgr.cpp
index 8de60d204a68..d493e035a792 100644
--- a/src/steamcompmgr.cpp
+++ b/src/steamcompmgr.cpp
@@ -1022,7 +1022,7 @@ unsigned int g_BlurFadeDuration = 0;
 int g_BlurRadius = 5;
 unsigned int g_BlurFadeStartTime = 0;
 
-pid_t focusWindow_pid;
+pid_t focusWindow_pid, sdFocusWindow_pid;
 std::shared_ptr<std::string> focusWindow_engine = nullptr;
 
 focus_t g_steamcompmgr_xdg_focus;
@@ -4161,8 +4161,8 @@ determine_and_apply_focus( global_focus_t *pFocus )
 
 #if HAVE_LIBSYSTEMD
 	pid_t newFocusedWindowPID = pFocus->focusWindow ? pFocus->focusWindow->pid : 0;
-	if (g_dbus && focusWindow_pid != newFocusedWindowPID) {
-		const char *unfocusedWindowUnit = unit_from_pid(focusWindow_pid);
+	if (g_dbus && sdFocusWindow_pid != newFocusedWindowPID) {
+		const char *unfocusedWindowUnit = unit_from_pid(sdFocusWindow_pid);
 		const char *focusedWindowUnit = unit_from_pid(newFocusedWindowPID);
 		bool sameUnit = unfocusedWindowUnit && focusedWindowUnit && !strcmp(unfocusedWindowUnit, focusedWindowUnit);
 
@@ -4187,7 +4187,7 @@ determine_and_apply_focus( global_focus_t *pFocus )
 		focusedBaseAppId = pFocus->focusWindow->appID;
 		focusedAppId = pFocus->inputFocusWindow->appID;
 		focused_display = get_win_display_name(pFocus->focusWindow);
-		focusWindow_pid = pFocus->focusWindow->pid;
+		sdFocusWindow_pid = pFocus->focusWindow->pid;
 	}
 
 	g_focusedBaseAppId = (uint32_t)focusedAppId;
@@ -6507,6 +6507,7 @@ bool handle_done_commit( steamcompmgr_win_t *w, xwayland_ctx_t *ctx, uint64_t co
 					hasRepaint = true;
 
 					focusWindow_engine = w->engineName;
+					focusWindow_pid = w->pid;
 				}
 
 				if ( w == pFocus->overrideWindow )
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Autumn Ashton <misyl@froggi.es>
Date: Fri, 31 Oct 2025 21:38:53 +0000
Subject: backend: Add support for deferred backends

So we can eg. init Gamescope headlessly then transition into a backend that only uses SAMPLED modifiers like SteamVR.

This way we can init VRWebHelper in a Gamescope before SteamVR fully comes up.
---
 src/Backends/DRMBackend.cpp      |   8 +-
 src/Backends/DeferredBackend.h   | 432 +++++++++++++++++++++++++++++++
 src/Backends/HeadlessBackend.cpp |   2 +-
 src/Backends/OpenVRBackend.cpp   |  50 ++--
 src/Backends/SDLBackend.cpp      |  30 +--
 src/Backends/WaylandBackend.cpp  |  12 +-
 src/backend.cpp                  |  22 +-
 src/backend.h                    |  10 +-
 src/main.cpp                     |  14 +
 src/rendervulkan.cpp             |  31 ++-
 src/steamcompmgr.cpp             |  23 +-
 src/wlserver.cpp                 |   9 +
 12 files changed, 589 insertions(+), 54 deletions(-)
 create mode 100644 src/Backends/DeferredBackend.h

diff --git a/src/Backends/DRMBackend.cpp b/src/Backends/DRMBackend.cpp
index 1ec2699821f0..7361e5aedb39 100644
--- a/src/Backends/DRMBackend.cpp
+++ b/src/Backends/DRMBackend.cpp
@@ -1523,7 +1523,7 @@ void finish_drm(struct drm_t *drm)
 	// page-flip handler thread.
 }
 
-gamescope::OwningRc<gamescope::IBackendFb> drm_fbid_from_dmabuf( struct drm_t *drm, struct wlr_buffer *buf, struct wlr_dmabuf_attributes *dma_buf )
+gamescope::OwningRc<gamescope::IBackendFb> drm_fbid_from_dmabuf( struct drm_t *drm, struct wlr_dmabuf_attributes *dma_buf )
 {
 	gamescope::OwningRc<gamescope::IBackendFb> pBackendFb;
 	uint32_t fb_id = 0;
@@ -2525,7 +2525,7 @@ drm_prepare_liftoff( struct drm_t *drm, const struct FrameInfo_t *frameInfo, boo
 		if ( i < frameInfo->layerCount )
 		{
 			const FrameInfo_t::Layer_t *pLayer = &frameInfo->layers[ i ];
-			gamescope::CDRMFb *pDrmFb = static_cast<gamescope::CDRMFb *>( pLayer->tex ? pLayer->tex->GetBackendFb() : nullptr );
+			gamescope::CDRMFb *pDrmFb = static_cast<gamescope::CDRMFb *>( pLayer->tex ? pLayer->tex->GetBackendFb()->Unwrap() : nullptr );
 
 			if ( pDrmFb == nullptr )
 			{
@@ -3710,9 +3710,9 @@ namespace gamescope
 			return std::make_shared<BackendBlob>( data, uBlob, true );
 		}
 
-		virtual OwningRc<IBackendFb> ImportDmabufToBackend( wlr_buffer *pBuffer, wlr_dmabuf_attributes *pDmaBuf ) override
+		virtual OwningRc<IBackendFb> ImportDmabufToBackend( wlr_dmabuf_attributes *pDmaBuf ) override
 		{
-			return drm_fbid_from_dmabuf( &g_DRM, pBuffer, pDmaBuf );
+			return drm_fbid_from_dmabuf( &g_DRM, pDmaBuf );
 		}
 
 		virtual bool UsesModifiers() const override
diff --git a/src/Backends/DeferredBackend.h b/src/Backends/DeferredBackend.h
new file mode 100644
index 000000000000..1cc7f52c340b
--- /dev/null
+++ b/src/Backends/DeferredBackend.h
@@ -0,0 +1,432 @@
+#include "backend.h"
+#include "refresh_rate.h"
+#include "steamcompmgr.hpp"
+
+#include <cassert>
+#include <shared_mutex>
+
+extern int g_nPreferredOutputWidth;
+extern int g_nPreferredOutputHeight;
+
+std::span<const uint64_t> GetSupportedSampleModifiers( uint32_t uDrmFormat );
+
+namespace gamescope
+{
+    class CDeferredBackend;
+
+    class CDeferredFb final : public CBaseBackendFb
+    {
+    public:
+        CDeferredFb( CDeferredBackend *pDeferredBackend, struct wlr_dmabuf_attributes *attributes )
+            : m_pDeferredBackend{ pDeferredBackend }
+        {
+            wlr_dmabuf_attributes_copy( &m_attributes, attributes );
+        }
+
+        ~CDeferredFb()
+        {
+            wlr_dmabuf_attributes_finish( &m_attributes );
+        }
+        
+        IBackendFb *Unwrap() override;
+    private:
+        CDeferredBackend *m_pDeferredBackend = nullptr;
+        struct wlr_dmabuf_attributes m_attributes;
+        OwningRc<IBackendFb> m_pChild;
+    };
+
+	class CDeferredBackend final : public CBaseBackend
+	{
+	public:
+		CDeferredBackend( IBackend *pChild )
+            : m_pChild{ pChild }
+		{
+		}
+
+		virtual ~CDeferredBackend()
+		{
+            if ( m_pChild )
+            {
+                delete m_pChild;
+                m_pChild = nullptr;
+            }
+		}
+
+		virtual bool Init() override
+		{
+			g_nOutputWidth = g_nPreferredOutputWidth;
+			g_nOutputHeight = g_nPreferredOutputHeight;
+			g_nOutputRefresh = g_nNestedRefresh;
+
+			if ( g_nOutputHeight == 0 )
+			{
+				if ( g_nOutputWidth != 0 )
+				{
+					fprintf( stderr, "Cannot specify -W without -H\n" );
+					return false;
+				}
+				g_nOutputHeight = 720;
+			}
+			if ( g_nOutputWidth == 0 )
+				g_nOutputWidth = g_nOutputHeight * 16 / 9;
+			if ( g_nOutputRefresh == 0 )
+				g_nOutputRefresh = ConvertHztomHz( 60 );
+
+            if ( !vulkan_init( vulkan_get_instance(), VK_NULL_HANDLE ) )
+            {
+                return false;
+            }
+
+            if ( !wlsession_init() )
+            {
+                fprintf( stderr, "Failed to initialize deferred backend\n" );
+                return false;
+            }
+
+            TryInittingChild();
+
+			return true;
+		}
+
+		virtual bool PostInit() override
+		{
+            {
+                std::shared_lock lock{ m_mutInit };
+                m_bDonePostInit = true;
+
+                if ( m_bInittedChild )
+                    return m_pChild->PostInit();
+            }
+
+            return true;
+		}
+
+        virtual std::span<const char *const> GetInstanceExtensions() const override
+		{
+            // Basically what's needed to support SDL + OpenVR.
+            static const std::array<const char *const, 8> requiredInstanceExts
+            {
+                VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME,
+                VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME,
+                VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME,
+                VK_KHR_SURFACE_EXTENSION_NAME,
+                "VK_KHR_xcb_surface",
+                "VK_KHR_xlib_surface",
+                "VK_KHR_wayland_surface",
+                VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME,
+            };
+			return std::span<const char *const>{ requiredInstanceExts };
+		}
+        virtual std::span<const char *const> GetDeviceExtensions( VkPhysicalDevice pVkPhysicalDevice ) const override
+		{
+            // Basically what's needed to support OpenVR.
+            static const std::array<const char *const, 8> requiredDeviceExts
+            {
+                VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME,
+                VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME,
+                VK_KHR_TIMELINE_SEMAPHORE_EXTENSION_NAME,
+                VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME,
+                VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME,
+                VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME,
+                VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME,
+                VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME,
+            };
+			return std::span<const char *const>{ requiredDeviceExts };
+		}
+        virtual VkImageLayout GetPresentLayout() const override
+		{
+            {
+                std::shared_lock lock{ m_mutInit };
+                if ( m_bInittedChild )
+                    return m_pChild->GetPresentLayout();
+            }
+
+			return VK_IMAGE_LAYOUT_GENERAL;
+		}
+		virtual void GetPreferredOutputFormat( uint32_t *pPrimaryPlaneFormat, uint32_t *pOverlayPlaneFormat ) const override
+		{
+			*pPrimaryPlaneFormat = VulkanFormatToDRM( VK_FORMAT_A2B10G10R10_UNORM_PACK32 );
+			*pOverlayPlaneFormat = VulkanFormatToDRM( VK_FORMAT_B8G8R8A8_UNORM );
+		}
+		virtual bool ValidPhysicalDevice( VkPhysicalDevice pVkPhysicalDevice ) const override
+		{
+			return true;
+		}
+
+		virtual void DirtyState( bool bForce, bool bForceModeset ) override
+		{
+            {
+                std::shared_lock lock{ m_mutInit };
+                if ( m_bInittedChild )
+                    return m_pChild->DirtyState( bForce, bForceModeset );
+            }
+		}
+
+		virtual bool PollState() override
+		{
+            TryInittingChild();
+            {
+                std::shared_lock lock{ m_mutInit };
+                if ( m_bInittedChild )
+                    return m_pChild->PollState() || m_bJustInittedPoll;
+            }
+			return false;
+		}
+
+		virtual std::shared_ptr<BackendBlob> CreateBackendBlob( const std::type_info &type, std::span<const uint8_t> data ) override
+		{
+            // Only dummy backend blobs supported.
+			return std::make_shared<BackendBlob>( data );
+		}
+
+		virtual OwningRc<IBackendFb> ImportDmabufToBackend( wlr_dmabuf_attributes *pDmaBuf ) override
+		{
+			return new CDeferredFb( this, pDmaBuf );
+		}
+
+		virtual bool UsesModifiers() const override
+		{
+            return true;
+		}
+		virtual std::span<const uint64_t> GetSupportedModifiers( uint32_t uDrmFormat ) const override
+		{
+			return GetSupportedSampleModifiers( uDrmFormat );
+		}
+
+		virtual IBackendConnector *GetCurrentConnector() override
+		{
+            {
+                std::shared_lock lock{ m_mutInit };
+                if ( m_bInittedChild )
+                    return m_pChild->GetCurrentConnector();
+            }
+
+            return nullptr;
+		}
+		virtual IBackendConnector *GetConnector( GamescopeScreenType eScreenType ) override
+		{
+            {
+                std::shared_lock lock{ m_mutInit };
+                if ( m_bInittedChild )
+                    return m_pChild->GetConnector( eScreenType );
+            }
+            
+			return nullptr;
+		}
+
+		virtual bool SupportsPlaneHardwareCursor() const override
+		{
+            // Doesn't need to be 'initted' for this check.
+            return m_pChild->SupportsPlaneHardwareCursor();
+		}
+
+		virtual bool SupportsTearing() const override
+		{
+            {
+                std::shared_lock lock{ m_mutInit };
+                if ( m_bInittedChild )
+                    return m_pChild->SupportsTearing();
+            }
+            
+			return false;
+		}
+
+		virtual bool UsesVulkanSwapchain() const override
+		{
+            // Doesn't need to be 'initted' for this check.
+            return m_pChild->UsesVulkanSwapchain();
+		}
+
+        virtual bool IsSessionBased() const override
+		{
+            // Doesn't need to be 'initted' for this check.
+            return m_pChild->IsSessionBased();
+		}
+
+		virtual bool SupportsExplicitSync() const override
+		{
+            // Doesn't need to be 'initted' for this check.
+            return m_pChild->SupportsExplicitSync();
+		}
+
+		virtual bool IsPaused() const override
+		{
+            {
+                std::shared_lock lock{ m_mutInit };
+                if ( m_bInittedChild )
+                    return m_pChild->IsPaused();
+            }
+
+            // We are always "paused" when not initted.
+            // Don't do any commits!
+			return true;
+		}
+
+		virtual bool IsVisible() const override
+		{
+            {
+                std::shared_lock lock{ m_mutInit };
+                if ( m_bInittedChild )
+                    return m_pChild->IsVisible();
+            }
+
+			return true;
+		}
+
+		virtual glm::uvec2 CursorSurfaceSize( glm::uvec2 uvecSize ) const override
+		{
+            {
+                std::shared_lock lock{ m_mutInit };
+                if ( m_bInittedChild )
+                    return m_pChild->CursorSurfaceSize( uvecSize );
+            }
+
+			return uvecSize;
+		}
+
+		virtual bool HackTemporarySetDynamicRefresh( int nRefresh ) override
+		{
+            {
+                std::shared_lock lock{ m_mutInit };
+                if ( m_bInittedChild )
+                    return m_pChild->HackTemporarySetDynamicRefresh( nRefresh );
+            }
+
+			return false;
+		}
+
+		virtual void HackUpdatePatchedEdid() override
+		{
+            {
+                std::shared_lock lock{ m_mutInit };
+                if ( m_bInittedChild )
+                    return m_pChild->HackUpdatePatchedEdid();
+            }
+		}
+
+        virtual bool NeedsFrameSync() const override
+        {
+            // Deferred backends do not support frame sync.
+            return false;
+        }
+
+        virtual TouchClickMode GetTouchClickMode() override
+        {
+            // Doesn't need to be 'initted' for this check.
+            return m_pChild->GetTouchClickMode();
+        }
+
+        virtual void DumpDebugInfo() override
+        {
+            // Doesn't need to be 'initted' for this check.
+            return m_pChild->DumpDebugInfo();
+        }
+
+        virtual bool UsesVirtualConnectors() override
+        {
+            // Doesn't need to be 'initted' for this check.
+            return m_pChild->UsesVirtualConnectors();
+        }
+        virtual std::shared_ptr<IBackendConnector> CreateVirtualConnector( uint64_t ulVirtualConnectorKey ) override
+        {
+            {
+                std::shared_lock lock{ m_mutInit };
+                if ( m_bInittedChild )
+                    return m_pChild->CreateVirtualConnector( ulVirtualConnectorKey );
+            }
+
+            return nullptr;
+        }
+
+        virtual void NotifyPhysicalInput( InputType eInputType ) override
+        {
+            {
+                std::shared_lock lock{ m_mutInit };
+                if ( m_bInittedChild )
+                    return m_pChild->NotifyPhysicalInput( eInputType );
+            }
+        }
+
+        virtual bool SupportsVROverlayForwarding() override
+        {
+            // Doesn't need to be 'initted' for this check.
+            return m_pChild->SupportsVROverlayForwarding();
+        }
+        virtual void ForwardFramebuffer( std::shared_ptr<IBackendPlane> &pPlane, IBackendFb *pFramebuffer, const void *pData ) override
+        {
+            {
+                std::shared_lock lock{ m_mutInit };
+                if ( m_bInittedChild )
+                    return m_pChild->ForwardFramebuffer( pPlane, pFramebuffer, pData );
+            }
+        }
+
+        bool IsChildInitted()
+        {
+            return m_bInittedChild;
+        }
+
+        IBackend *GetChild()
+        {
+            return m_pChild;
+        }
+
+        bool NewlyInitted() override
+        {
+            return m_bJustInittedClient.exchange( false );
+        }
+
+	protected:
+
+		virtual void OnBackendBlobDestroyed( BackendBlob *pBlob ) override
+		{
+		}
+
+	private:
+
+        void TryInittingChild()
+        {
+            if ( !m_bInittedChild )
+            {
+                std::unique_lock lock{ m_mutInit };
+                if ( !m_bInittedChild )
+                {
+                    if ( m_pChild->Init() )
+                    {
+                        m_bInittedChild = true;
+
+                        if ( m_bDonePostInit )
+                        {
+                            bool bRet = m_pChild->PostInit();
+                            assert( bRet && "PostInit failed!" );
+                        }
+
+                        m_bJustInittedClient = true;
+                        m_bJustInittedPoll = true;
+                    }
+                }
+            }
+        }
+
+        IBackend *m_pChild = nullptr;
+        mutable std::shared_mutex m_mutInit;
+        bool m_bDonePostInit = false;
+
+        std::atomic<bool> m_bInittedChild = { false };
+        std::atomic<bool> m_bJustInittedClient = { false };
+        std::atomic<bool> m_bJustInittedPoll = { false };
+	};
+
+    IBackendFb *CDeferredFb::Unwrap()
+    {
+        assert( m_pDeferredBackend->IsChildInitted() );
+
+        if ( !m_pChild )
+        {
+            m_pChild = m_pDeferredBackend->GetChild()->ImportDmabufToBackend( &m_attributes );
+        }
+
+        return m_pChild.get();
+    }
+
+}
diff --git a/src/Backends/HeadlessBackend.cpp b/src/Backends/HeadlessBackend.cpp
index 6f683721212a..8e4540066e75 100644
--- a/src/Backends/HeadlessBackend.cpp
+++ b/src/Backends/HeadlessBackend.cpp
@@ -180,7 +180,7 @@ namespace gamescope
 			return std::make_shared<BackendBlob>( data );
 		}
 
-		virtual OwningRc<IBackendFb> ImportDmabufToBackend( wlr_buffer *pBuffer, wlr_dmabuf_attributes *pDmaBuf ) override
+		virtual OwningRc<IBackendFb> ImportDmabufToBackend( wlr_dmabuf_attributes *pDmaBuf ) override
 		{
 			return new CBaseBackendFb();
 		}
diff --git a/src/Backends/OpenVRBackend.cpp b/src/Backends/OpenVRBackend.cpp
index 6391628876e7..cb0a15c65ac7 100644
--- a/src/Backends/OpenVRBackend.cpp
+++ b/src/Backends/OpenVRBackend.cpp
@@ -48,6 +48,7 @@ extern std::string g_reshade_effect;
 extern gamescope::ConVar<bool> cv_hdr_enabled;
 
 extern uint64_t g_SteamCompMgrLimitedAppRefreshCycle;
+extern bool g_bAllowDeferredBackend;
 
 void MakeFocusDirty();
 void update_connector_display_info_wl(struct drm_t *drm);
@@ -553,33 +554,37 @@ namespace gamescope
                 m_pchOverlayName = "Gamescope";
 
             m_pIPCResourceManager = vr::VRIPCResourceManager();
-            if ( m_pIPCResourceManager )
-            {
-                uint32_t uFormatCount = 0;
-                m_pIPCResourceManager->GetDmabufFormats( &uFormatCount, nullptr );
 
-                if ( uFormatCount )
+            if ( !g_bAllowDeferredBackend )
+            {
+                if ( m_pIPCResourceManager )
                 {
-                    std::vector<uint32_t> uFormats;
-                    uFormats.resize( uFormatCount );
-                    m_pIPCResourceManager->GetDmabufFormats( &uFormatCount, uFormats.data() );
+                    uint32_t uFormatCount = 0;
+                    m_pIPCResourceManager->GetDmabufFormats( &uFormatCount, nullptr );
 
-                    for ( uint32_t i = 0; i < uFormatCount; i++ )
+                    if ( uFormatCount )
                     {
-                        uint32_t uFormat = uFormats[i];
-                        uint32_t uModifierCount = 0;
-                        m_pIPCResourceManager->GetDmabufModifiers( vr::VRApplication_Overlay, uFormat, &uModifierCount, nullptr );
+                        std::vector<uint32_t> uFormats;
+                        uFormats.resize( uFormatCount );
+                        m_pIPCResourceManager->GetDmabufFormats( &uFormatCount, uFormats.data() );
 
-                        if ( uModifierCount )
+                        for ( uint32_t i = 0; i < uFormatCount; i++ )
                         {
-                            std::vector<uint64_t> ulModifiers;
-                            ulModifiers.resize( uModifierCount );
-                            m_pIPCResourceManager->GetDmabufModifiers( vr::VRApplication_Overlay, uFormat, &uModifierCount, ulModifiers.data() );
+                            uint32_t uFormat = uFormats[i];
+                            uint32_t uModifierCount = 0;
+                            m_pIPCResourceManager->GetDmabufModifiers( vr::VRApplication_Overlay, uFormat, &uModifierCount, nullptr );
 
-                            for ( uint64_t ulModifier : ulModifiers )
+                            if ( uModifierCount )
                             {
-                                if ( ulModifier != DRM_FORMAT_MOD_INVALID )
-                                    m_FormatModifiers[uFormat].emplace_back( ulModifier );
+                                std::vector<uint64_t> ulModifiers;
+                                ulModifiers.resize( uModifierCount );
+                                m_pIPCResourceManager->GetDmabufModifiers( vr::VRApplication_Overlay, uFormat, &uModifierCount, ulModifiers.data() );
+
+                                for ( uint64_t ulModifier : ulModifiers )
+                                {
+                                    if ( ulModifier != DRM_FORMAT_MOD_INVALID )
+                                        m_FormatModifiers[uFormat].emplace_back( ulModifier );
+                                }
                             }
                         }
                     }
@@ -677,7 +682,7 @@ namespace gamescope
 			return std::make_shared<BackendBlob>( data );
 		}
 
-		virtual OwningRc<IBackendFb> ImportDmabufToBackend( wlr_buffer *pBuffer, wlr_dmabuf_attributes *pDmaBuf ) override
+		virtual OwningRc<IBackendFb> ImportDmabufToBackend( wlr_dmabuf_attributes *pDmaBuf ) override
 		{
             if ( UsesModifiers() )
             {
@@ -739,6 +744,9 @@ namespace gamescope
             if ( !cv_vr_use_modifiers )
                 return false;
 
+            if ( g_bAllowDeferredBackend )
+                return true;
+
             if ( !m_pIPCResourceManager )
                 return false;
 
@@ -1834,7 +1842,7 @@ namespace gamescope
                     vr::VROverlay()->ShowOverlay( m_hOverlay );
                 }
 
-                pFb = static_cast<COpenVRFb *>( oState->pTexture->GetBackendFb() );
+                pFb = static_cast<COpenVRFb *>( oState->pTexture->GetBackendFb()->Unwrap() );
                 vr::SharedTextureHandle_t ulHandle = pFb->GetSharedTextureHandle();
 
                 vr::Texture_t texture = { (void *)&ulHandle, vr::TextureType_SharedTextureHandle, vr::ColorSpace_Gamma };
diff --git a/src/Backends/SDLBackend.cpp b/src/Backends/SDLBackend.cpp
index 2bb8fb06ef0c..87bde7e2f13b 100644
--- a/src/Backends/SDLBackend.cpp
+++ b/src/Backends/SDLBackend.cpp
@@ -55,10 +55,12 @@ namespace gamescope
 		GAMESCOPE_SDL_EVENT_COUNT,
 	};
 
+	class CSDLBackend;
+
 	class CSDLConnector final : public CBaseBackendConnector, public INestedHints
 	{
 	public:
-		CSDLConnector();
+		CSDLConnector( CSDLBackend *pBackend );
 		virtual bool Init();
 
 		virtual ~CSDLConnector();
@@ -121,6 +123,7 @@ namespace gamescope
 		SDL_Window *GetSDLWindow() const { return m_pWindow; }
 		VkSurfaceKHR GetVulkanSurface() const { return m_pVkSurface; }
 	private:
+		CSDLBackend *m_pBackend = nullptr;
 		SDL_Window *m_pWindow = nullptr;
 		VkSurfaceKHR m_pVkSurface = VK_NULL_HANDLE;
 		BackendConnectorHDRInfo m_HDRInfo{};
@@ -148,7 +151,7 @@ namespace gamescope
 
 		virtual std::shared_ptr<BackendBlob> CreateBackendBlob( const std::type_info &type, std::span<const uint8_t> data ) override;
 
-        virtual OwningRc<IBackendFb> ImportDmabufToBackend( wlr_buffer *pBuffer, wlr_dmabuf_attributes *pDmaBuf ) override;
+        virtual OwningRc<IBackendFb> ImportDmabufToBackend( wlr_dmabuf_attributes *pDmaBuf ) override;
 		virtual bool UsesModifiers() const override;
 		virtual std::span<const uint64_t> GetSupportedModifiers( uint32_t uDrmFormat ) const override;
 
@@ -208,7 +211,8 @@ namespace gamescope
 	// CSDLConnector
 	//////////////////
 
-	CSDLConnector::CSDLConnector()
+	CSDLConnector::CSDLConnector( CSDLBackend *pBackend )
+		: m_pBackend{ pBackend }
 	{
 	}
 
@@ -357,28 +361,23 @@ namespace gamescope
 
 	void CSDLConnector::SetCursorImage( std::shared_ptr<INestedHints::CursorInfo> info )
 	{
-		CSDLBackend *pBackend = static_cast<CSDLBackend *>( GetBackend() );
-		pBackend->SetCursorImage( std::move( info ) );
+		m_pBackend->SetCursorImage( std::move( info ) );
 	}
 	void CSDLConnector::SetRelativeMouseMode( bool bRelative )
 	{
-		CSDLBackend *pBackend = static_cast<CSDLBackend *>( GetBackend() );
-		pBackend->SetRelativeMouseMode( bRelative );
+		m_pBackend->SetRelativeMouseMode( bRelative );
 	}
 	void CSDLConnector::SetVisible( bool bVisible )
 	{
-		CSDLBackend *pBackend = static_cast<CSDLBackend *>( GetBackend() );
-		pBackend->SetVisible( bVisible );
+		m_pBackend->SetVisible( bVisible );
 	}
 	void CSDLConnector::SetTitle( std::shared_ptr<std::string> szTitle )
 	{
-		CSDLBackend *pBackend = static_cast<CSDLBackend *>( GetBackend() );
-		pBackend->SetTitle( std::move( szTitle ) );
+		m_pBackend->SetTitle( std::move( szTitle ) );
 	}
 	void CSDLConnector::SetIcon( std::shared_ptr<std::vector<uint32_t>> uIconPixels )
 	{
-		CSDLBackend *pBackend = static_cast<CSDLBackend *>( GetBackend() );
-		pBackend->SetIcon( std::move( uIconPixels ) );
+		m_pBackend->SetIcon( std::move( uIconPixels ) );
 	}
 
     void CSDLConnector::SetSelection( std::shared_ptr<std::string> szContents, GamescopeSelection eSelection )
@@ -394,7 +393,8 @@ namespace gamescope
 	////////////////
 
 	CSDLBackend::CSDLBackend()
-		: m_SDLThread{ [this](){ this->SDLThreadFunc(); } }
+		: m_Connector{ this }
+		, m_SDLThread{ [this](){ this->SDLThreadFunc(); } }
 	{
 	}
 
@@ -449,7 +449,7 @@ namespace gamescope
 		return std::make_shared<BackendBlob>( data );
 	}
 
-	OwningRc<IBackendFb> CSDLBackend::ImportDmabufToBackend( wlr_buffer *pBuffer, wlr_dmabuf_attributes *pDmaBuf )
+	OwningRc<IBackendFb> CSDLBackend::ImportDmabufToBackend( wlr_dmabuf_attributes *pDmaBuf )
 	{
 		return new CBaseBackendFb();
 	}
diff --git a/src/Backends/WaylandBackend.cpp b/src/Backends/WaylandBackend.cpp
index f9f7d254860f..0d682fb359f6 100644
--- a/src/Backends/WaylandBackend.cpp
+++ b/src/Backends/WaylandBackend.cpp
@@ -652,7 +652,7 @@ namespace gamescope
 
         virtual std::shared_ptr<BackendBlob> CreateBackendBlob( const std::type_info &type, std::span<const uint8_t> data ) override;
 
-        virtual OwningRc<IBackendFb> ImportDmabufToBackend( wlr_buffer *pBuffer, wlr_dmabuf_attributes *pDmaBuf ) override;
+        virtual OwningRc<IBackendFb> ImportDmabufToBackend( wlr_dmabuf_attributes *pDmaBuf ) override;
         virtual bool UsesModifiers() const override;
         virtual std::span<const uint64_t> GetSupportedModifiers( uint32_t uDrmFormat ) const override;
 
@@ -1625,7 +1625,7 @@ namespace gamescope
 
     void CWaylandPlane::Present( const FrameInfo_t::Layer_t *pLayer )
     {
-        CWaylandFb *pWaylandFb = pLayer && pLayer->tex != nullptr ? static_cast<CWaylandFb*>( pLayer->tex->GetBackendFb() ) : nullptr;
+        CWaylandFb *pWaylandFb = pLayer && pLayer->tex != nullptr ? static_cast<CWaylandFb*>( pLayer->tex->GetBackendFb()->Unwrap() ) : nullptr;
         wl_buffer *pBuffer = pWaylandFb ? pWaylandFb->GetHostBuffer() : nullptr;
 
         if ( pBuffer )
@@ -2064,7 +2064,7 @@ namespace gamescope
         {
             return false;
         }
-
+        
         if ( !wlsession_init() )
         {
             xdg_log.errorf( "Failed to initialize Wayland session" );
@@ -2077,6 +2077,8 @@ namespace gamescope
             return false;
         }
 
+        xdg_log.infof( "Initted Wayland backend" );
+
         return true;
     }
 
@@ -2108,6 +2110,8 @@ namespace gamescope
         m_pDefaultCursorInfo = GetX11HostCursor();
         m_pDefaultCursorSurface = CursorInfoToSurface( m_pDefaultCursorInfo );
 
+        xdg_log.infof( "Post-Initted Wayland backend" );
+
         return true;
     }
 
@@ -2198,7 +2202,7 @@ namespace gamescope
         return std::make_shared<BackendBlob>( data );
     }
 
-    OwningRc<IBackendFb> CWaylandBackend::ImportDmabufToBackend( wlr_buffer *pClientBuffer, wlr_dmabuf_attributes *pDmaBuf )
+    OwningRc<IBackendFb> CWaylandBackend::ImportDmabufToBackend( wlr_dmabuf_attributes *pDmaBuf )
     {
         zwp_linux_buffer_params_v1 *pBufferParams = zwp_linux_dmabuf_v1_create_params( m_pLinuxDmabuf );
         if ( !pBufferParams )
diff --git a/src/backend.cpp b/src/backend.cpp
index e5e7e2247b56..a6deb0edda73 100644
--- a/src/backend.cpp
+++ b/src/backend.cpp
@@ -1,4 +1,5 @@
 #include "backend.h"
+#include "Backends/DeferredBackend.h"
 #include "vblankmanager.hpp"
 #include "convar.h"
 #include "wlserver.hpp"
@@ -10,6 +11,8 @@
 extern void sleep_until_nanos(uint64_t nanos);
 extern bool env_to_bool(const char *env);
 
+extern bool g_bAllowDeferredBackend;
+
 namespace gamescope
 {
     ConVar<VirtualConnectorStrategy> cv_backend_virtual_connector_strategy( "backend_virtual_connector_strategy", VirtualConnectorStrategies::SingleApplication );
@@ -38,9 +41,22 @@ namespace gamescope
             s_pBackend = pBackend;
             if ( !s_pBackend->Init() )
             {
-                delete s_pBackend;
-                s_pBackend = nullptr;
-                return false;
+                if ( g_bAllowDeferredBackend )
+                {
+                    s_pBackend = new CDeferredBackend( pBackend );
+                    if ( !s_pBackend->Init() )
+                    {
+                        delete s_pBackend;
+                        s_pBackend = nullptr;
+                        return false;
+                    }
+                }
+                else
+                {
+                    delete s_pBackend;
+                    s_pBackend = nullptr;
+                    return false;
+                }
             }
         }
 
diff --git a/src/backend.h b/src/backend.h
index 2731aec2625a..b866462fdb2b 100644
--- a/src/backend.h
+++ b/src/backend.h
@@ -256,6 +256,8 @@ namespace gamescope
     public:
         virtual void SetBuffer( wlr_buffer *pClientBuffer ) = 0;
         virtual void SetReleasePoint( std::shared_ptr<CReleaseTimelinePoint> pReleasePoint ) = 0;
+
+        virtual IBackendFb *Unwrap() = 0;
     };
 
     class IBackendPlane
@@ -276,6 +278,8 @@ namespace gamescope
         void SetBuffer( wlr_buffer *pClientBuffer ) override;
         void SetReleasePoint( std::shared_ptr<CReleaseTimelinePoint> pReleasePoint ) override;
 
+        virtual IBackendFb *Unwrap() override { return this; };
+
     private:
         wlr_buffer *m_pClientBuffer = nullptr;
         std::shared_ptr<CReleaseTimelinePoint> m_pReleasePoint;
@@ -311,7 +315,7 @@ namespace gamescope
         //
         // shared_ptr owns the structure.
         // Rc manages acquire/release of buffer to/from client while imported.
-        virtual OwningRc<IBackendFb> ImportDmabufToBackend( wlr_buffer *pBuffer, wlr_dmabuf_attributes *pDmaBuf ) = 0;
+        virtual OwningRc<IBackendFb> ImportDmabufToBackend( wlr_dmabuf_attributes *pDmaBuf ) = 0;
 
         virtual bool UsesModifiers() const = 0;
         virtual std::span<const uint64_t> GetSupportedModifiers( uint32_t uDrmFormat ) const = 0;
@@ -366,6 +370,8 @@ namespace gamescope
         virtual bool SupportsVROverlayForwarding() = 0;
         virtual void ForwardFramebuffer( std::shared_ptr<IBackendPlane> &pPlane, IBackendFb *pFramebuffer, const void *pData ) = 0;
 
+        virtual bool NewlyInitted() = 0;
+
         static IBackend *Get();
         template <typename T>
         static bool Set();
@@ -398,6 +404,8 @@ namespace gamescope
 
         virtual bool SupportsVROverlayForwarding() override { return false; }
         virtual void ForwardFramebuffer( std::shared_ptr<IBackendPlane> &pPlane, IBackendFb *pFramebuffer, const void *pData ) override {}
+
+        virtual bool NewlyInitted() override { return false; }
     };
 
     // This is a blob of data that may be associated with
diff --git a/src/main.cpp b/src/main.cpp
index cdb35c3b2518..23921a9dca19 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -45,11 +45,14 @@ using namespace std::literals;
 
 EStreamColorspace g_ForcedNV12ColorSpace = k_EStreamColorspace_Unknown;
 extern gamescope::ConVar<bool> cv_adaptive_sync;
+extern gamescope::ConVar<bool> cv_shutdown_on_primary_child_death;
 
 const char *gamescope_optstring = nullptr;
 const char *g_pOriginalDisplay = nullptr;
 const char *g_pOriginalWaylandDisplay = nullptr;
 
+bool g_bAllowDeferredBackend = false;
+
 int g_nCursorScaleHeight = -1;
 
 const struct option *gamescope_options = (struct option[]){
@@ -151,6 +154,9 @@ const struct option *gamescope_options = (struct option[]){
 	// Steam Deck options
 	{ "mura-map", required_argument, nullptr, 0 },
 
+	{ "allow-deferred-backend", no_argument, nullptr, 0 },
+	{ "keep-alive", no_argument, nullptr, 0 },
+
 	{} // keep last
 };
 
@@ -265,6 +271,10 @@ const char usage[] =
 	"Steam Deck options:\n"
 	"  --mura-map                     Set the mura compensation map to use for the display. Takes in a path to the mura map.\n"
 	"\n"
+	"Platform options:\n"
+	"  --allow-deferred-backend       Allows initting the backend in a deferred way, if it doesn't work immediately. (Note: This has some very minor correctness compromises that you should consider wrt. your platform with modifiers, etc).\n"
+	"  --keep-alive                   Keep Gamescope alive even when the primary process has died.\n"
+	"\n"
 	"Keyboard shortcuts:\n"
 	"  Super + F                      toggle fullscreen\n"
 	"  Super + N                      toggle nearest neighbour filtering\n"
@@ -810,6 +820,10 @@ int main(int argc, char **argv)
 					g_nCursorScaleHeight = parse_integer(optarg, opt_name);
 				} else if (strcmp(opt_name, "mangoapp") == 0) {
 					g_bLaunchMangoapp = true;
+				} else if (strcmp(opt_name, "allow-deferred-backend") == 0) {
+					g_bAllowDeferredBackend = true;
+				} else if (strcmp(opt_name, "keep-alive") == 0) {
+					cv_shutdown_on_primary_child_death = false;
 				} else if (strcmp(opt_name, "virtual-connector-strategy") == 0) {
 					for ( uint32_t i = 0; i < gamescope::VirtualConnectorStrategies::Count; i++ )
 					{
diff --git a/src/rendervulkan.cpp b/src/rendervulkan.cpp
index 6f5141fde3ec..f97b301542c7 100644
--- a/src/rendervulkan.cpp
+++ b/src/rendervulkan.cpp
@@ -56,6 +56,7 @@
 #include "reshade_effect_manager.hpp"
 
 extern bool g_bWasPartialComposite;
+extern bool g_bAllowDeferredBackend;
 
 static constexpr mat3x4 g_rgb2yuv_srgb_to_bt601_limited = {{
   { 0.257f, 0.504f, 0.098f, 0.0625f },
@@ -124,9 +125,19 @@ uint32_t g_uCompositeDebug = 0u;
 gamescope::ConVar<uint32_t> cv_composite_debug{ "composite_debug", 0, "Debug composition flags" };
 
 static std::map< VkFormat, std::map< uint64_t, VkDrmFormatModifierPropertiesEXT > > DRMModifierProps = {};
+static std::unordered_map<uint32_t, std::vector<uint64_t>> s_SampledModifierFormats = {};
 static struct wlr_drm_format_set sampledShmFormats = {};
 static struct wlr_drm_format_set sampledDRMFormats = {};
 
+std::span<const uint64_t> GetSupportedSampleModifiers( uint32_t uDrmFormat )
+{
+	auto iter = s_SampledModifierFormats.find( uDrmFormat );
+	if ( iter == s_SampledModifierFormats.end() )
+		return std::span<const uint64_t>{};
+
+	return std::span<const uint64_t>{ iter->second.begin(), iter->second.end() };
+}
+
 static LogScope vk_log("vulkan");
 
 static void vk_errorf(VkResult result, const char *fmt, ...) {
@@ -2444,7 +2455,7 @@ bool CVulkanTexture::BInit( uint32_t width, uint32_t height, uint32_t depth, uin
 
 	if ( flags.bFlippable == true )
 	{
-		m_pBackendFb = GetBackend()->ImportDmabufToBackend( nullptr, &m_dmabuf );
+		m_pBackendFb = GetBackend()->ImportDmabufToBackend( &m_dmabuf );
 	}
 
 	bool bHasAlpha = pDMA ? DRMFormatHasAlpha( pDMA->format ) : true;
@@ -2822,10 +2833,15 @@ bool vulkan_init_format(VkFormat format, uint32_t drmFormat)
 				continue;
 			}
 
-			if ( GetBackend()->UsesModifiers() && !gamescope::Algorithm::Contains( GetBackend()->GetSupportedModifiers( drmFormat ), modifier ) )
-				continue;
+			// The deferred backend exposes all sample-able formats as supported modifiers.
+			if ( !g_bAllowDeferredBackend )
+			{
+				if ( GetBackend()->UsesModifiers() && !gamescope::Algorithm::Contains( GetBackend()->GetSupportedModifiers( drmFormat ), modifier ) )
+					continue;
+			}
 
 			wlr_drm_format_set_add( &sampledDRMFormats, drmFormat, modifier );
+			s_SampledModifierFormats[ drmFormat ].emplace_back( modifier );
 		}
 
 		DRMModifierProps[ format ] = map;
@@ -3493,6 +3509,13 @@ VkInstance vulkan_get_instance( void )
 
 bool vulkan_init( VkInstance instance, VkSurfaceKHR surface )
 {
+	static bool s_bInitted = false;
+	if ( s_bInitted )
+	{
+		g_output.surface = surface;
+		return true;
+	}
+
 	if (!g_device.BInit(instance, surface))
 		return false;
 
@@ -3505,6 +3528,8 @@ bool vulkan_init( VkInstance instance, VkSurfaceKHR surface )
 		present_wait_thread.detach();
 	}
 
+	s_bInitted = true;
+
 	return true;
 }
 
diff --git a/src/steamcompmgr.cpp b/src/steamcompmgr.cpp
index d493e035a792..3b03f7efb5e5 100644
--- a/src/steamcompmgr.cpp
+++ b/src/steamcompmgr.cpp
@@ -1404,7 +1404,7 @@ import_commit (
 	gamescope::OwningRc<gamescope::IBackendFb> pBackendFb;
 	if ( wlr_buffer_get_dmabuf( buf, &dmabuf ) )
 	{
-		pBackendFb = GetBackend()->ImportDmabufToBackend( buf, &dmabuf );
+		pBackendFb = GetBackend()->ImportDmabufToBackend( &dmabuf );
 	}
 
 	gamescope::OwningRc<CVulkanTexture> pOwnedTexture = vulkan_create_texture_from_wlr_buffer( buf, std::move( pBackendFb ) );
@@ -8165,15 +8165,34 @@ steamcompmgr_main(int argc, char **argv)
 			flush_root = true;
 		}
 
+		bool bBackendJustInitted = GetBackend()->NewlyInitted();
+
 		static gamescope::VirtualConnectorStrategy s_eLastVirtualConnectorStrategy = gamescope::cv_backend_virtual_connector_strategy;
 		gamescope::VirtualConnectorStrategy eVirtualConnectorStrategy = gamescope::cv_backend_virtual_connector_strategy;
 
-		if ( eVirtualConnectorStrategy != s_eLastVirtualConnectorStrategy )
+		if ( eVirtualConnectorStrategy != s_eLastVirtualConnectorStrategy || bBackendJustInitted )
 		{
 			// If our virtual connector strategy changes, clear out our virtual connector
 			// global focuses.
 			g_VirtualConnectorFocuses.clear();
 			s_eLastVirtualConnectorStrategy = eVirtualConnectorStrategy;
+
+			xwm_log.infof( "Late init of virtual connector stuff." );
+
+			if ( gamescope::VirtualConnectorIsSingleOutput() )
+			{
+				// misyl: Make the virtual connector up-front if we are in a single-output mode.
+				// So we don't delay in getting display/output info to the game
+				static constexpr uint64_t k_unSingleOutputVirtualConnectorKey = 0;
+
+				g_VirtualConnectorFocuses[ k_unSingleOutputVirtualConnectorKey ] = global_focus_t
+				{
+					.ulVirtualFocusKey = k_unSingleOutputVirtualConnectorKey,
+					.pVirtualConnector = GetBackend()->UsesVirtualConnectors() ? GetBackend()->CreateVirtualConnector( k_unSingleOutputVirtualConnectorKey ) : nullptr,
+				};
+			}
+
+			hasRepaint = true;
 		}
 
 #if 0
diff --git a/src/wlserver.cpp b/src/wlserver.cpp
index 60ea18e77076..bae509e5b601 100644
--- a/src/wlserver.cpp
+++ b/src/wlserver.cpp
@@ -1624,6 +1624,10 @@ static bool filter_global(const struct wl_client *client, const struct wl_global
 }
 
 bool wlsession_init( void ) {
+	static bool s_bInitted = false;
+	if ( s_bInitted )
+		return true;
+
 	wlr_log_init(WLR_DEBUG, handle_wlr_log);
 
 	wlserver.display = wl_display_create();
@@ -1639,7 +1643,10 @@ bool wlsession_init( void ) {
 
 #if HAVE_SESSION
 	if ( !GetBackend()->IsSessionBased() )
+	{
+		s_bInitted = true;
 		return true;
+	}
 
 	wlserver.wlr.session = wlr_session_create( wlserver.event_loop );
 	if ( wlserver.wlr.session == nullptr )
@@ -1652,6 +1659,8 @@ bool wlsession_init( void ) {
 	wl_signal_add( &wlserver.wlr.session->events.active, &wlserver.session_active );
 #endif
 
+	s_bInitted = true;
+
 	return true;
 }
 
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Martin kareem <Martykareem@outlook.com>
Date: Fri, 31 Oct 2025 19:45:17 -0400
Subject: fix: invert null checks in IsGamescopeProxy/Plane

The null checks were backwards - returning false for valid pointers
and trying to dereference null ones. Matches the pattern already used
in IsGamescopeToplevel.
---
 src/Backends/WaylandBackend.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/Backends/WaylandBackend.cpp b/src/Backends/WaylandBackend.cpp
index 0d682fb359f6..ab6d30c3973b 100644
--- a/src/Backends/WaylandBackend.cpp
+++ b/src/Backends/WaylandBackend.cpp
@@ -80,7 +80,7 @@ static inline uint32_t WaylandScaleToLogical( uint32_t pValue, uint32_t pFactor
 [[maybe_unused]] static bool IsGamescopeProxy( void *pProxy ) {
 	// HACK: this probably should never be called with a null pointer, but it
 	// was happening after a window was closed.
-	if ( pProxy )
+	if ( !pProxy )
 		return false;
 
 	const char* const* pTag = wl_proxy_get_tag( (wl_proxy *)pProxy );
@@ -93,7 +93,7 @@ static inline uint32_t WaylandScaleToLogical( uint32_t pValue, uint32_t pFactor
 [[maybe_unused]] static bool IsGamescopePlane( wl_surface *pSurface ) {
 	// HACK: this probably should never be called with a null pointer, but it
 	// was happening after a window was closed.
-	if ( pSurface )
+	if ( !pSurface )
 		return false;
 	const char* const* pTag = wl_proxy_get_tag( (wl_proxy *)pSurface );
 
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Autumn Ashton <misyl@froggi.es>
Date: Mon, 3 Nov 2025 21:41:12 +0000
Subject: steamcompmgr: Disable ffmpeg NV12 dump test

---
 src/steamcompmgr.cpp | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/src/steamcompmgr.cpp b/src/steamcompmgr.cpp
index 3b03f7efb5e5..f70bff6ae3b1 100644
--- a/src/steamcompmgr.cpp
+++ b/src/steamcompmgr.cpp
@@ -3070,6 +3070,10 @@ paint_all( global_focus_t *pFocus, bool async )
 						fwrite(mappedData, 1, pScreenshotTexture->totalSize(), file );
 						fclose(file);
 
+						bScreenshotSuccess = true;
+						xwm_log.infof("Screenshot saved to %s", oScreenshotInfo->szScreenshotPath.c_str());
+
+#if 0
 						char cmd[4096];
 						sprintf(cmd, "ffmpeg -f rawvideo -pixel_format nv12 -video_size %dx%d -i %s %s_encoded.png", pScreenshotTexture->width(), pScreenshotTexture->height(), oScreenshotInfo->szScreenshotPath.c_str(), oScreenshotInfo->szScreenshotPath.c_str() );
 
@@ -3081,8 +3085,8 @@ paint_all( global_focus_t *pFocus, bool async )
 							xwm_log.errorf( "Failed to save screenshot to %s", oScreenshotInfo->szScreenshotPath.c_str() );
 						} else {
 							xwm_log.infof("Screenshot saved to %s", oScreenshotInfo->szScreenshotPath.c_str());
-							bScreenshotSuccess = true;
 						}
+#endif
 					}
 					else
 					{
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Sam Lantinga <slouken@libsdl.org>
Date: Mon, 3 Nov 2025 17:27:26 -0800
Subject: Don't treat the streaming client video window as focusable

---
 src/steamcompmgr.cpp | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/src/steamcompmgr.cpp b/src/steamcompmgr.cpp
index f70bff6ae3b1..4fff294f6893 100644
--- a/src/steamcompmgr.cpp
+++ b/src/steamcompmgr.cpp
@@ -3646,6 +3646,12 @@ found:;
 			continue;
 		}
 
+		// Skip streaming client video window
+		if ( w->isSteamStreamingClientVideo )
+		{
+			continue;
+		}
+
 		if ( w->xwayland().a.map_state == IsViewable && w->xwayland().a.c_class == InputOutput &&
 			( win_has_game_id( w ) || window_is_steam( w ) || w->isSteamStreamingClient ) &&
 			 (w->opacity > TRANSLUCENT || w->isSteamStreamingClient ) )
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Autumn Ashton <misyl@froggi.es>
Date: Tue, 4 Nov 2025 20:53:06 +0000
Subject: DeferredBackend: Fix spamming PollState

Need to exchange this to false.
---
 src/Backends/DeferredBackend.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/Backends/DeferredBackend.h b/src/Backends/DeferredBackend.h
index 1cc7f52c340b..e7771bfb7280 100644
--- a/src/Backends/DeferredBackend.h
+++ b/src/Backends/DeferredBackend.h
@@ -168,7 +168,7 @@ namespace gamescope
             {
                 std::shared_lock lock{ m_mutInit };
                 if ( m_bInittedChild )
-                    return m_pChild->PollState() || m_bJustInittedPoll;
+                    return m_pChild->PollState() || m_bJustInittedPoll.exchange( false );
             }
 			return false;
 		}
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Olivier Tilloy <otilloy@igalia.com>
Date: Wed, 8 Oct 2025 12:04:19 +0200
Subject: steamcompmgr: Add a workaround for Forza Horizon 4 & 5

This prevents a fully black background window from being considered a dropdown,
thus stealing focus.
---
 src/steamcompmgr.cpp | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/src/steamcompmgr.cpp b/src/steamcompmgr.cpp
index 4fff294f6893..c8ba833cbbd1 100644
--- a/src/steamcompmgr.cpp
+++ b/src/steamcompmgr.cpp
@@ -3310,6 +3310,12 @@ win_maybe_a_dropdown( steamcompmgr_win_t *w )
 		( ( w->hwndStyleEx & invalidLayered ) == 0 ) )
 		return true;
 
+	// Forza Horizon 4 & 5 create a black background window that might incorrectly
+	// be considered a valid dropdown and steal focus.
+	if ( ( w->appID == 1293830 || w->appID == 1551360 ) &&
+		w->maybe_a_dropdown && w->requestedWidth == 0 && w->requestedHeight == 0 )
+		return false;
+
 	// Josh:
 	// The logic here is as follows. The window will be treated as a dropdown if:
 	// 
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Autumn Ashton <misyl@froggi.es>
Date: Mon, 29 Sep 2025 00:22:22 -0700
Subject: OpenVRBackend: Initial support for non-Steam apps

---
 src/Backends/DeferredBackend.h |  5 +++++
 src/Backends/OpenVRBackend.cpp | 39 +++++++++++++++++++++++++-------
 src/backend.h                  | 11 +++++++++
 src/steamcompmgr.cpp           | 41 ++++++++++++++++++++++++++++------
 src/steamcompmgr_shared.hpp    |  9 +++++++-
 src/wlserver.cpp               |  8 ++++---
 src/wlserver.hpp               |  6 ++++-
 7 files changed, 99 insertions(+), 20 deletions(-)

diff --git a/src/Backends/DeferredBackend.h b/src/Backends/DeferredBackend.h
index e7771bfb7280..3e4d22a6631a 100644
--- a/src/Backends/DeferredBackend.h
+++ b/src/Backends/DeferredBackend.h
@@ -376,6 +376,11 @@ namespace gamescope
             return m_bJustInittedClient.exchange( false );
         }
 
+        bool ShouldFitWindows() override
+        {
+            return m_pChild->ShouldFitWindows();
+        }
+
 	protected:
 
 		virtual void OnBackendBlobDestroyed( BackendBlob *pBlob ) override
diff --git a/src/Backends/OpenVRBackend.cpp b/src/Backends/OpenVRBackend.cpp
index cb0a15c65ac7..5c32f8bca497 100644
--- a/src/Backends/OpenVRBackend.cpp
+++ b/src/Backends/OpenVRBackend.cpp
@@ -25,6 +25,7 @@
 #include <string.h>
 #include <thread>
 #include <mutex>
+#include <format>
 
 struct wlserver_input_method;
 
@@ -947,6 +948,11 @@ namespace gamescope
             }
         }
 
+        bool ShouldFitWindows() override
+        {
+            return false;
+        }
+
         vr::IVRIPCResourceManagerClient *GetIPCResourceManager()
         {
             return m_pIPCResourceManager;
@@ -1503,6 +1509,11 @@ namespace gamescope
 
         bNeedsFullComposite |= !!(g_uCompositeDebug & CompositeDebugFlag::Heatmap);
 
+        // Non-Steam windows NEVER use composition!
+        bool bExplicitNonSteam = VirtualConnectorKeyIsNonSteamWindow( GetVirtualConnectorKey() );
+        if ( bExplicitNonSteam )
+            bNeedsFullComposite = false;
+
         if ( !bNeedsFullComposite )
         {
             bool bNeedsBacking = true;
@@ -1601,6 +1612,8 @@ namespace gamescope
     }
     void COpenVRConnector::SetIcon( std::shared_ptr<std::vector<uint32_t>> uIconPixels )
     {
+        bool bExplicitNonSteam = VirtualConnectorKeyIsNonSteamWindow( GetVirtualConnectorKey() );
+
         if ( cv_vr_use_window_icons && uIconPixels && uIconPixels->size() >= 3 )
         {
             const uint32_t uWidth = (*uIconPixels)[0];
@@ -1620,7 +1633,7 @@ namespace gamescope
 
             vr::VROverlay()->SetOverlayRaw( GetPrimaryPlane()->GetOverlayThumbnail(), &(*uIconPixels)[2], uWidth, uHeight, sizeof(uint32_t) );
         }
-        else if ( m_pBackend->GetOverlayIcon() )
+        else if ( m_pBackend->GetOverlayIcon() && !bExplicitNonSteam )
         {
             vr::VROverlay()->SetOverlayFromFile( GetPrimaryPlane()->GetOverlayThumbnail(), m_pBackend->GetOverlayIcon() );
         }
@@ -1744,6 +1757,8 @@ namespace gamescope
 
         std::string sOverlayKey = m_pBackend->GetOverlayKey();
 
+        bool bExplicitNonSteam = false;
+
         VirtualConnectorStrategy eStrategy = cv_backend_virtual_connector_strategy;
         if ( !VirtualConnectorStrategyIsSingleOutput( eStrategy ) )
         {
@@ -1751,17 +1766,25 @@ namespace gamescope
             bool bIsSteam = VirtualConnectorKeyIsSteam( ulKey );
             if ( !bIsSteam )
             {
-                const char *pszAppOverlayKey = m_pBackend->GetAppOverlayKey();
-                if ( pszAppOverlayKey && *pszAppOverlayKey )
+                bExplicitNonSteam = VirtualConnectorKeyIsNonSteamWindow( ulKey );
+                if ( bExplicitNonSteam )
                 {
-                    sOverlayKey = pszAppOverlayKey;
-                    sOverlayKey += ".";
+                    sOverlayKey = std::format( "gamescope.{}.window.{}", wlserver_get_wl_display_name(), ulKey & ~gamescope::k_ulNonSteamWindowBit );
                 }
                 else
                 {
-                    sOverlayKey += ".app.";
+                    const char *pszAppOverlayKey = m_pBackend->GetAppOverlayKey();
+                    if ( pszAppOverlayKey && *pszAppOverlayKey )
+                    {
+                        sOverlayKey = pszAppOverlayKey;
+                        sOverlayKey += ".";
+                    }
+                    else
+                    {
+                        sOverlayKey += ".app.";
+                    }
+                    sOverlayKey += std::to_string( m_pConnector->GetVirtualConnectorKey() );
                 }
-                sOverlayKey += std::to_string( m_pConnector->GetVirtualConnectorKey() );
             }
         }
 
@@ -1787,7 +1810,7 @@ namespace gamescope
             vr::VROverlay()->SetOverlayCurvature	( m_hOverlay,  m_pBackend->GetPhysicalCurvature() );
             vr::VROverlay()->SetOverlayPreCurvePitch( m_hOverlay,  m_pBackend->GetPhysicalPreCurvePitch() );
 
-            if ( m_pBackend->GetOverlayIcon() )
+            if ( m_pBackend->GetOverlayIcon() && !bExplicitNonSteam )
             {
                 vr::EVROverlayError err = vr::VROverlay()->SetOverlayFromFile( m_hOverlayThumbnail, m_pBackend->GetOverlayIcon() );
                 if( err != vr::VROverlayError_None )
diff --git a/src/backend.h b/src/backend.h
index b866462fdb2b..18cb67f8c3f5 100644
--- a/src/backend.h
+++ b/src/backend.h
@@ -66,6 +66,13 @@ namespace gamescope
         return VirtualConnectorInSteamPerAppState() && ulKey == 769;
     }
 
+    static constexpr uint64_t k_ulNonSteamWindowBit = ( uint64_t( 1 ) << 63u );
+
+    static inline bool VirtualConnectorKeyIsNonSteamWindow( VirtualConnectorKey_t ulKey )
+    {
+        return VirtualConnectorInSteamPerAppState() && ( ulKey & k_ulNonSteamWindowBit ) == k_ulNonSteamWindowBit;
+    }
+
     static inline std::string_view VirtualConnectorStrategyToString( VirtualConnectorStrategy eStrategy )
     {
         switch ( eStrategy )
@@ -372,6 +379,8 @@ namespace gamescope
 
         virtual bool NewlyInitted() = 0;
 
+        virtual bool ShouldFitWindows() = 0;
+
         static IBackend *Get();
         template <typename T>
         static bool Set();
@@ -406,6 +415,8 @@ namespace gamescope
         virtual void ForwardFramebuffer( std::shared_ptr<IBackendPlane> &pPlane, IBackendFb *pFramebuffer, const void *pData ) override {}
 
         virtual bool NewlyInitted() override { return false; }
+
+        virtual bool ShouldFitWindows() override { return true; }
     };
 
     // This is a blob of data that may be associated with
diff --git a/src/steamcompmgr.cpp b/src/steamcompmgr.cpp
index c8ba833cbbd1..e0e17f6f83fc 100644
--- a/src/steamcompmgr.cpp
+++ b/src/steamcompmgr.cpp
@@ -29,6 +29,7 @@
  *   says above. Not that I can really do anything about it
  */
 
+#include "backend.h"
 #include "gamescope_shared.h"
 #include "xwayland_ctx.hpp"
 #include <X11/X.h>
@@ -2064,6 +2065,9 @@ paint_window_commit( const gamescope::Rc<commit_t> &lastCommit, steamcompmgr_win
 	float baseScaleRatio_x = 1.0;
 	float baseScaleRatio_y = 1.0;
 
+	if ( !GetBackend()->ShouldFitWindows() )
+		fit = nullptr;
+
 	// Exit out if we have no window or
 	// no commit.
 	//
@@ -3658,8 +3662,13 @@ found:;
 			continue;
 		}
 
+		if ( gamescope::cv_backend_virtual_connector_strategy == gamescope::VirtualConnectorStrategies::SteamControlled )
+		{
+			if ( !( win_has_game_id( w ) || window_is_steam( w ) || w->isSteamStreamingClient ) )	
+				continue;
+		}
+
 		if ( w->xwayland().a.map_state == IsViewable && w->xwayland().a.c_class == InputOutput &&
-			( win_has_game_id( w ) || window_is_steam( w ) || w->isSteamStreamingClient ) &&
 			 (w->opacity > TRANSLUCENT || w->isSteamStreamingClient ) )
 		{
 			vecPossibleFocusWindows.push_back( w );
@@ -3726,11 +3735,21 @@ void xwayland_ctx_t::DetermineAndApplyFocus( const std::vector< steamcompmgr_win
 		}
 	}
 
-	gamescope::VirtualConnectorStrategy eStrategy = gamescope::cv_backend_virtual_connector_strategy == gamescope::VirtualConnectorStrategies::SteamControlled
-		? gamescope::VirtualConnectorStrategies::SteamControlled
-		: gamescope::VirtualConnectorStrategies::PerWindow;
+	gamescope::VirtualConnectorStrategy eStrategy = gamescope::VirtualConnectorStrategies::PerWindow;
+	gamescope::VirtualConnectorKey_t ulKey = 0;
 
-	pick_primary_focus_and_override( &ctx->focus, ctx->focusControlWindow, vecPossibleFocusWindows, false, vecFocuscontrolAppIDs, 0, eStrategy );
+	if ( ctx->xwayland_server->get_index() != 0 )
+	{
+		eStrategy = gamescope::VirtualConnectorStrategies::SteamControlled;
+		ulKey = 0;
+	}
+	else if ( GetBackend() && GetBackend()->GetCurrentConnector() )
+	{
+		eStrategy = gamescope::cv_backend_virtual_connector_strategy;
+		ulKey = GetBackend()->GetCurrentConnector()->GetVirtualConnectorKey();
+	}
+
+	pick_primary_focus_and_override( &ctx->focus, ctx->focusControlWindow, vecPossibleFocusWindows, false, vecFocuscontrolAppIDs, ulKey, eStrategy );
 
 	if ( inputFocus == NULL )
 	{
@@ -5040,15 +5059,23 @@ damage_win(xwayland_ctx_t *ctx, XDamageNotifyEvent *de)
 	if (w->IsAnyOverlay() && !w->opacity)
 		return;
 
+	bool bHasAppID = w->appID != 0;
+
+	if ( gamescope::cv_backend_virtual_connector_strategy != gamescope::VirtualConnectorStrategies::SteamControlled )
+	{
+		bHasAppID = true;
+	}
+
 	// First damage event we get, compute focus; we only want to focus damaged
 	// windows to have meaningful frames.
-	if (w->appID && w->xwayland().damage_sequence == 0)
+	/// FIXME APPID FOCUS STRATERGY FOR 
+	if (bHasAppID && w->xwayland().damage_sequence == 0)
 		MakeFocusDirty();
 
 	w->xwayland().damage_sequence = damageSequence++;
 
 	// If we just passed the focused window, we might be eliglible to take over
-	if ( focus && focus != w && w->appID &&
+	if ( focus && focus != w && bHasAppID &&
 		w->xwayland().damage_sequence > focus->xwayland().damage_sequence)
 		MakeFocusDirty();
 
diff --git a/src/steamcompmgr_shared.hpp b/src/steamcompmgr_shared.hpp
index 1b3a6e787a74..5cb29733bb26 100644
--- a/src/steamcompmgr_shared.hpp
+++ b/src/steamcompmgr_shared.hpp
@@ -233,7 +233,14 @@ struct steamcompmgr_win_t {
 		case gamescope::VirtualConnectorStrategies::SteamControlled:
 			return 0;
 		case gamescope::VirtualConnectorStrategies::PerAppId:
-			return static_cast<gamescope::VirtualConnectorKey_t>( this->appID );
+			if ( this->appID )
+			{
+				return static_cast<gamescope::VirtualConnectorKey_t>( this->appID );
+			}
+			else
+			{
+				return static_cast<gamescope::VirtualConnectorKey_t>( gamescope::k_ulNonSteamWindowBit | this->seq );	
+			}
 		case gamescope::VirtualConnectorStrategies::PerWindow:
 			return static_cast<gamescope::VirtualConnectorKey_t>( this->seq );
 		}
diff --git a/src/wlserver.cpp b/src/wlserver.cpp
index bae509e5b601..bda03ced25d3 100644
--- a/src/wlserver.cpp
+++ b/src/wlserver.cpp
@@ -1710,8 +1710,10 @@ void wlsession_close_kms()
 
 #endif
 
-gamescope_xwayland_server_t::gamescope_xwayland_server_t(wl_display *display)
+gamescope_xwayland_server_t::gamescope_xwayland_server_t(wl_display *display, int nIndex)
 {
+	m_nIndex = nIndex;
+
 	struct wlr_xwayland_server_options xwayland_options = {
 		.lazy = false,
 		.enable_wm = false,
@@ -2099,7 +2101,7 @@ bool wlserver_init( void ) {
 
 	for (int i = 0; i < g_nXWaylandCount; i++)
 	{
-		auto server = std::make_unique<gamescope_xwayland_server_t>(wlserver.display);
+		auto server = std::make_unique<gamescope_xwayland_server_t>(wlserver.display, i);
 		wlserver.wlr.xwayland_servers.emplace_back(std::move(server));
 	}
 
@@ -3196,7 +3198,7 @@ uint32_t wlserver_make_new_xwayland_server()
 {
 	assert( wlserver_is_lock_held() );
 
-	auto& server = wlserver.wlr.xwayland_servers.emplace_back(std::make_unique<gamescope_xwayland_server_t>(wlserver.display));
+	auto& server = wlserver.wlr.xwayland_servers.emplace_back(std::make_unique<gamescope_xwayland_server_t>(wlserver.display, (int)wlserver.wlr.xwayland_servers.size()));
 
 	while (!server->is_xwayland_ready()) {
 		wl_display_flush_clients(wlserver.display);
diff --git a/src/wlserver.hpp b/src/wlserver.hpp
index 375211efeb6f..eb1270806d0c 100644
--- a/src/wlserver.hpp
+++ b/src/wlserver.hpp
@@ -57,7 +57,7 @@ bool wlserver_is_lock_held(void);
 class gamescope_xwayland_server_t
 {
 public:
-	gamescope_xwayland_server_t(wl_display *display);
+	gamescope_xwayland_server_t(wl_display *display, int nIndex);
 	~gamescope_xwayland_server_t();
 
 	void on_xwayland_ready(void *data);
@@ -86,6 +86,8 @@ public:
 
 	void update_output_info();
 
+	int get_index() const { return m_nIndex; }
+
 private:
 	struct wlr_xwayland_server *xwayland_server = NULL;
 	struct wl_listener xwayland_ready_listener = { .notify = xwayland_ready_callback };
@@ -98,6 +100,8 @@ private:
 	bool xwayland_ready = false;
 	_XDisplay *dpy = NULL;
 
+	int m_nIndex = 0;
+
 	std::mutex wayland_commit_lock;
 	std::vector<ResListEntry_t> wayland_commit_queue;
 };
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <git@antheas.dev>
Date: Fri, 22 Nov 2024 01:37:48 +0100
Subject: [NA] add dev script

---
 sync.sh | 21 +++++++++++++++++++++
 1 file changed, 21 insertions(+)
 create mode 100755 sync.sh

diff --git a/sync.sh b/sync.sh
new file mode 100755
index 000000000000..8dd5815d4aeb
--- /dev/null
+++ b/sync.sh
@@ -0,0 +1,21 @@
+if [ -z "$1" ]; then
+    echo "Usage: $0 <host>"
+    exit 1
+fi
+
+HOST=$1
+RSYNC="rsync -rv --exclude .git --exclude venv --exclude __pycache__'"
+USER=${USER:-bazzite}
+
+set -e
+
+meson build/ -Dforce_fallback_for=stb,libdisplay-info,libliftoff,wlroots,vkroots -Denable_openvr_support=false
+ninja -C build/
+scp build/src/gamescope ${HOST}:gamescope
+
+ssh $HOST /bin/bash << EOF
+    sudo rpm-ostree usroverlay --hotfix
+    sudo mv ~/gamescope /usr/bin/gamescope
+    bazzite-session-select gamescope
+    # sudo reboot
+EOF
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Matthew Anderson <ruinairas1992@gmail.com>
Date: Fri, 17 May 2024 21:56:55 -0500
Subject: feat: add --custom-refresh-rates option (+ fixes)

Commit originally by Matthew, external fixes by Kyle, and new system check
move by Antheas.

Co-authored-by: Kyle Gospodnetich <me@kylegospodneti.ch>
Co-authored-by: Antheas Kapenekakis <git@antheas.dev>
---
 src/Backends/DRMBackend.cpp |  4 +++-
 src/main.cpp                | 31 +++++++++++++++++++++++++++++++
 src/main.hpp                |  2 ++
 3 files changed, 36 insertions(+), 1 deletion(-)

diff --git a/src/Backends/DRMBackend.cpp b/src/Backends/DRMBackend.cpp
index 7361e5aedb39..25a37eabc39c 100644
--- a/src/Backends/DRMBackend.cpp
+++ b/src/Backends/DRMBackend.cpp
@@ -2342,8 +2342,10 @@ namespace gamescope
 			}
 			else
 			{
+				if ( g_customRefreshRates.size() > 0 && GetScreenType() == GAMESCOPE_SCREEN_TYPE_INTERNAL )
+					m_Mutable.ValidDynamicRefreshRates = g_customRefreshRates;
 				// Unknown display, see if there are any other refresh rates in the EDID we can get.
-				if ( GetScreenType() == GAMESCOPE_SCREEN_TYPE_INTERNAL || cv_drm_allow_dynamic_modes_for_external_display )
+				else if ( GetScreenType() == GAMESCOPE_SCREEN_TYPE_INTERNAL  || cv_drm_allow_dynamic_modes_for_external_display )
 				{
 					const drmModeModeInfo *pPreferredMode = find_mode( m_pConnector.get(), 0, 0, 0 );
 
diff --git a/src/main.cpp b/src/main.cpp
index 23921a9dca19..531c8e806840 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -136,6 +136,7 @@ const struct option *gamescope_options = (struct option[]){
 	{ "fade-out-duration", required_argument, nullptr, 0 },
 	{ "force-orientation", required_argument, nullptr, 0 },
 	{ "force-windows-fullscreen", no_argument, nullptr, 0 },
+	{ "custom-refresh-rates", required_argument, nullptr, 0 },
 
 	{ "disable-color-management", no_argument, nullptr, 0 },
 	{ "sdr-gamut-wideness", required_argument, nullptr, 0 },
@@ -213,6 +214,7 @@ const char usage[] =
 	"  --hdr-itm-target-nits          set the target luminace of the inverse tone mapping process.\n"
 	"                                 Default: 1000 nits, Max: 10000 nits\n"
 	"  --framerate-limit              Set a simple framerate limit. Used as a divisor of the refresh rate, rounds down eg 60 / 59 -> 60fps, 60 / 25 -> 30fps. Default: 0, disabled.\n"
+	"  --custom-refresh-rates         Set custom refresh rates for the output. eg: 60,90,110-120\n"
 	"  --mangoapp                     Launch with the mangoapp (mangohud) performance overlay enabled. You should use this instead of using mangohud on the game or gamescope.\n"
 	"  --adaptive-sync                Enable adaptive sync if available (variable rate refresh)\n"
 	"\n"
@@ -470,6 +472,33 @@ static float parse_float(const char *str, const char *optionName)
 	}
 }
 
+std::vector<uint32_t> g_customRefreshRates;
+// eg: 60,60,90,110-120
+static std::vector<uint32_t> parse_custom_refresh_rates( const char *str )
+{
+	std::vector<uint32_t> rates;
+	char *token = strtok( strdup(str), ",");
+	while (token)
+	{
+		char *dash = strchr(token, '-');
+		if (dash)
+		{
+			uint32_t start = atoi(token);
+			uint32_t end = atoi(dash + 1);
+			for (uint32_t i = start; i <= end; i++)
+			{
+				rates.push_back(i);
+			}
+		}
+		else
+		{
+			rates.push_back(atoi(token));
+		}
+		token = strtok(nullptr, ",");
+	}
+	return rates;
+}
+
 struct sigaction handle_signal_action = {};
 
 void ShutdownGamescope()
@@ -793,6 +822,8 @@ int main(int argc, char **argv)
 					g_eGamescopeModeGeneration = parse_gamescope_mode_generation( optarg );
 				} else if (strcmp(opt_name, "force-orientation") == 0) {
 					g_DesiredInternalOrientation = force_orientation( optarg );
+				} else if (strcmp(opt_name, "custom-refresh-rates") == 0) {
+					g_customRefreshRates = parse_custom_refresh_rates( optarg );
 				} else if (strcmp(opt_name, "sharpness") == 0 ||
 						   strcmp(opt_name, "fsr-sharpness") == 0) {
 					g_upscaleFilterSharpness = parse_integer( optarg, opt_name );
diff --git a/src/main.hpp b/src/main.hpp
index 2e6fb833af12..390c04a63ecd 100644
--- a/src/main.hpp
+++ b/src/main.hpp
@@ -3,6 +3,7 @@
 #include <getopt.h>
 
 #include <atomic>
+#include <vector>
 
 extern const char *gamescope_optstring;
 extern const struct option *gamescope_options;
@@ -28,6 +29,7 @@ extern bool g_bGrabbed;
 
 extern float g_mouseSensitivity;
 extern const char *g_sOutputName;
+extern std::vector<uint32_t> g_customRefreshRates;
 
 enum class GamescopeUpscaleFilter : uint32_t
 {
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Renn <8340896+AkazaRenn@users.noreply.github.com>
Date: Fri, 11 Oct 2024 17:48:26 +0200
Subject: fix(deck): Use super + 1/2 for Overlay/QAM

Replaces the patch for CTRL + 1/2 for Overlay/QAM with Super + 1/2 and
allows for CTRL for a smooth transition.

Suggested-by: Antheas Kapenekakis <git@antheas.dev>
---
 src/wlserver.cpp | 23 ++++++++++++++++++++++-
 1 file changed, 22 insertions(+), 1 deletion(-)

diff --git a/src/wlserver.cpp b/src/wlserver.cpp
index bda03ced25d3..b154bd40d7fd 100644
--- a/src/wlserver.cpp
+++ b/src/wlserver.cpp
@@ -296,6 +296,9 @@ static void wlserver_handle_modifiers(struct wl_listener *listener, void *data)
 	bump_input_counter();
 }
 
+// false if GS_ENABLE_CTRL_12 exists and is 0, true otherwise
+bool env_gs_enable_ctrl_12 = getenv("GS_ENABLE_CTRL_12") ? (getenv("GS_ENABLE_CTRL_12")[0] != '0') : true;
+
 static void wlserver_handle_key(struct wl_listener *listener, void *data)
 {
 	struct wlr_keyboard *keyboard = &wlserver.keyboard_group->keyboard;
@@ -319,7 +322,14 @@ static void wlserver_handle_key(struct wl_listener *listener, void *data)
 		keysym == XKB_KEY_XF86AudioLowerVolume ||
 		keysym == XKB_KEY_XF86AudioRaiseVolume ||
 		keysym == XKB_KEY_XF86PowerOff;
-	if ( ( event->state == WL_KEYBOARD_KEY_STATE_PRESSED || event->state == WL_KEYBOARD_KEY_STATE_RELEASED ) && forbidden_key )
+
+	// Check for steam overlay key (ctrl/super + 1/2)
+	bool is_steamshortcut =
+		((env_gs_enable_ctrl_12 && (keyboard->modifiers.depressed & WLR_MODIFIER_CTRL)) ||
+		 (keyboard->modifiers.depressed & WLR_MODIFIER_LOGO)) &&
+		(keysym == XKB_KEY_1 || keysym == XKB_KEY_2);
+
+	if ( ( event->state == WL_KEYBOARD_KEY_STATE_PRESSED || event->state == WL_KEYBOARD_KEY_STATE_RELEASED ) && (forbidden_key || is_steamshortcut) )
 	{
 		// Always send volume+/- to root server only, to avoid it reaching the game.
 		struct wlr_surface *old_kb_surf = wlserver.kb_focus_surface;
@@ -328,6 +338,17 @@ static void wlserver_handle_key(struct wl_listener *listener, void *data)
 		{
 			wlserver_keyboardfocus( new_kb_surf, false );
 			wlr_seat_set_keyboard( wlserver.wlr.seat, keyboard );
+
+			if (is_steamshortcut)
+			{
+				// send ctrl down modifier to trigger the overlay
+				wlr_keyboard_modifiers ctrl_down_modifier;
+				ctrl_down_modifier.depressed = WLR_MODIFIER_CTRL;
+				ctrl_down_modifier.latched = WLR_MODIFIER_CTRL;
+				ctrl_down_modifier.locked = WLR_MODIFIER_CTRL;
+				wlr_seat_keyboard_notify_modifiers(wlserver.wlr.seat, &ctrl_down_modifier);
+			}
+
 			wlr_seat_keyboard_notify_key( wlserver.wlr.seat, event->time_msec, event->keycode, event->state );
 			wlserver_keyboardfocus( old_kb_surf, false );
 			return;
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <git@antheas.dev>
Date: Mon, 14 Oct 2024 22:42:20 +0200
Subject: fix(display-config): always fill in mutable refresh rates

Assume the user is not lying to us when they fill in dynamic_refresh_rates
and that gamescope will work with e.g., CVT, so accept it even if no
custom modeline generation has been provided.
---
 src/Backends/DRMBackend.cpp | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/src/Backends/DRMBackend.cpp b/src/Backends/DRMBackend.cpp
index 25a37eabc39c..0c97713955b7 100644
--- a/src/Backends/DRMBackend.cpp
+++ b/src/Backends/DRMBackend.cpp
@@ -2258,7 +2258,9 @@ namespace gamescope
 				sol::optional<sol::table> otDynamicRefreshRates = tTable["dynamic_refresh_rates"];
 				sol::optional<sol::function> ofnDynamicModegen = tTable["dynamic_modegen"];
 
-				if ( otDynamicRefreshRates && ofnDynamicModegen )
+				if ( otDynamicRefreshRates && !ofnDynamicModegen )
+					m_Mutable.ValidDynamicRefreshRates = TableToVector<uint32_t>( *otDynamicRefreshRates );
+				else if ( otDynamicRefreshRates && ofnDynamicModegen )
 				{
 					m_Mutable.ValidDynamicRefreshRates = TableToVector<uint32_t>( *otDynamicRefreshRates );
 
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <git@antheas.dev>
Date: Wed, 30 Oct 2024 00:39:03 +0100
Subject: fix(battery): run at half hz while at steamUI with atom

---
 src/steamcompmgr.cpp | 53 +++++++++++++++++++++++++++++++++++---------
 src/xwayland_ctx.hpp |  2 ++
 2 files changed, 45 insertions(+), 10 deletions(-)

diff --git a/src/steamcompmgr.cpp b/src/steamcompmgr.cpp
index e0e17f6f83fc..bf7ae6cad13e 100644
--- a/src/steamcompmgr.cpp
+++ b/src/steamcompmgr.cpp
@@ -175,6 +175,8 @@ uint32_t g_reshade_technique_idx = 0;
 
 bool g_bSteamIsActiveWindow = false;
 bool g_bForceInternal = false;
+bool b_bForceFrameLimit = false;
+bool g_bRefreshHalveEnable = false;
 
 namespace gamescope
 {
@@ -931,6 +933,7 @@ uint64_t g_uCurrentBasePlaneCommitID = 0;
 bool g_bCurrentBasePlaneIsFifo = false;
 
 static int g_nSteamCompMgrTargetFPS = 0;
+static int g_nSteamCompMgrTargetFPSreq = 0;
 static uint64_t g_uDynamicRefreshEqualityTime = 0;
 static int g_nDynamicRefreshRate[gamescope::GAMESCOPE_SCREEN_TYPE_COUNT] = { 0, 0 };
 // Delay to stop modes flickering back and forth.
@@ -950,7 +953,7 @@ static void _update_app_target_refresh_cycle()
 	int target_fps = g_nCombinedAppRefreshCycleOverride[type];
 
 	g_nDynamicRefreshRate[ type ] = 0;
-	g_nSteamCompMgrTargetFPS = 0;
+	g_nSteamCompMgrTargetFPSreq = 0;
 
 	if ( !target_fps )
 	{
@@ -959,7 +962,7 @@ static void _update_app_target_refresh_cycle()
 
 	if ( g_nCombinedAppRefreshCycleChangeFPS[ type ] )
 	{
-		g_nSteamCompMgrTargetFPS = target_fps;
+		g_nSteamCompMgrTargetFPSreq = target_fps;
 	}
 
 	if ( g_nCombinedAppRefreshCycleChangeRefresh[ type ] )
@@ -980,9 +983,9 @@ static void _update_app_target_refresh_cycle()
 
 static void update_app_target_refresh_cycle()
 {
-	int nPrevFPSLimit = g_nSteamCompMgrTargetFPS;
+	int nPrevFPSLimit = g_nSteamCompMgrTargetFPSreq;
 	_update_app_target_refresh_cycle();
-	if ( !!g_nSteamCompMgrTargetFPS != !!nPrevFPSLimit )
+	if ( !!g_nSteamCompMgrTargetFPSreq != !!nPrevFPSLimit )
 		update_runtime_info();
 }
 
@@ -5418,7 +5421,7 @@ update_runtime_info()
 	if ( g_nRuntimeInfoFd < 0 )
 		return;
 
-	uint32_t limiter_enabled = g_nSteamCompMgrTargetFPS != 0 ? 1 : 0;
+	uint32_t limiter_enabled = g_nSteamCompMgrTargetFPSreq != 0 ? 1 : 0;
 	pwrite( g_nRuntimeInfoFd, &limiter_enabled, sizeof( limiter_enabled ), 0 );
 }
 
@@ -5481,7 +5484,7 @@ static bool steamcompmgr_should_vblank_window( bool bShouldLimitFPS, uint64_t vb
 	{
 		bool bCloseEnough = std::abs( g_nSteamCompMgrTargetFPS - nRefreshHz ) < 2;
 
-		if ( g_nSteamCompMgrTargetFPS && bShouldLimitFPS && w && !bCloseEnough )
+		if ( g_nSteamCompMgrTargetFPS && (bShouldLimitFPS || b_bForceFrameLimit)  && w && !bCloseEnough )
 		{
 			uint64_t schedule = w->last_commit_first_latch_time + g_SteamCompMgrLimitedAppRefreshCycle;
 
@@ -5499,7 +5502,7 @@ static bool steamcompmgr_should_vblank_window( bool bShouldLimitFPS, uint64_t vb
 	}
 	else
 	{
-		if ( g_nSteamCompMgrTargetFPS && bShouldLimitFPS && nRefreshHz > nTargetFPS )
+		if ( g_nSteamCompMgrTargetFPS && (bShouldLimitFPS || b_bForceFrameLimit)  && nRefreshHz > nTargetFPS )
 		{
 			int nVblankDivisor = nRefreshHz / nTargetFPS;
 
@@ -5909,7 +5912,7 @@ handle_property_notify(xwayland_ctx_t *ctx, XPropertyEvent *ev)
 	}
 	if ( ev->atom == ctx->atoms.gamescopeFPSLimit )
 	{
-		g_nSteamCompMgrTargetFPS = get_prop( ctx, ctx->root, ctx->atoms.gamescopeFPSLimit, 0 );
+		g_nSteamCompMgrTargetFPSreq = get_prop( ctx, ctx->root, ctx->atoms.gamescopeFPSLimit, 0 );
 		update_runtime_info();
 	}
 	for (int i = 0; i < gamescope::GAMESCOPE_SCREEN_TYPE_COUNT; i++)
@@ -6340,6 +6343,10 @@ handle_property_notify(xwayland_ctx_t *ctx, XPropertyEvent *ev)
 			MakeFocusDirty();
 		}
 	}
+	if ( ev->atom == ctx->atoms.gamescopeFrameHalveAtom )
+	{
+		g_bRefreshHalveEnable = !!get_prop( ctx, ctx->root, ctx->atoms.gamescopeFrameHalveAtom, 0 );
+	}
 }
 
 static int
@@ -6723,7 +6730,7 @@ void handle_presented_for_window( steamcompmgr_win_t* w )
 
 	uint64_t next_refresh_time = g_SteamCompMgrVBlankTime.schedule.ulTargetVBlank;
 
-	uint64_t refresh_cycle = g_nSteamCompMgrTargetFPS && steamcompmgr_window_should_limit_fps( w )
+	uint64_t refresh_cycle = g_nSteamCompMgrTargetFPS && (steamcompmgr_window_should_limit_fps( w ) || b_bForceFrameLimit)
 		? g_SteamCompMgrLimitedAppRefreshCycle
 		: g_SteamCompMgrAppRefreshCycle;
 
@@ -7585,6 +7592,8 @@ void init_xwayland_ctx(uint32_t serverId, gamescope_xwayland_server_t *xwayland_
 	ctx->atoms.primarySelection = XInternAtom(ctx->dpy, "PRIMARY", false);
 	ctx->atoms.targets = XInternAtom(ctx->dpy, "TARGETS", false);
 
+	ctx->atoms.gamescopeFrameHalveAtom = XInternAtom( ctx->dpy, "GAMESCOPE_STEAMUI_HALFHZ", false );;
+
 	ctx->root_width = DisplayWidth(ctx->dpy, ctx->scr);
 	ctx->root_height = DisplayHeight(ctx->dpy, ctx->scr);
 
@@ -8014,7 +8023,7 @@ steamcompmgr_main(int argc, char **argv)
 				} else if (strcmp(opt_name, "hdr-itm-target-nits") == 0) {
 					g_flHDRItmTargetNits = atof(optarg);
 				} else if (strcmp(opt_name, "framerate-limit") == 0) {
-					g_nSteamCompMgrTargetFPS = atoi(optarg);
+					g_nSteamCompMgrTargetFPSreq = atoi(optarg);
 				} else if (strcmp(opt_name, "reshade-effect") == 0) {
 					g_reshade_effect = optarg;
 				} else if (strcmp(opt_name, "reshade-technique-idx") == 0) {
@@ -8182,6 +8191,30 @@ steamcompmgr_main(int argc, char **argv)
 		// as a question.
 		const bool bIsVBlankFromTimer = vblank;
 
+		// Halve refresh rate on SteamUI
+		bool isSteam = false;
+		for (auto &iter : g_VirtualConnectorFocuses)
+		{
+			global_focus_t *pFocus = &iter.second;
+			if (window_is_steam( pFocus->focusWindow )) {
+				isSteam = true;
+				break;
+			}
+		}
+		if ( g_bRefreshHalveEnable && isSteam ) {
+			int nRealRefreshHz = gamescope::ConvertmHzToHz( g_nNestedRefresh ? g_nNestedRefresh : g_nOutputRefresh );
+			if (nRealRefreshHz > 100 && (g_nSteamCompMgrTargetFPSreq > 50 || !g_nSteamCompMgrTargetFPSreq)) {
+				g_nSteamCompMgrTargetFPS = nRealRefreshHz / 2;
+				b_bForceFrameLimit = true;
+			} else {
+				g_nSteamCompMgrTargetFPS = g_nSteamCompMgrTargetFPSreq;
+				b_bForceFrameLimit = false;
+			}
+		} else {
+			g_nSteamCompMgrTargetFPS = g_nSteamCompMgrTargetFPSreq;
+			b_bForceFrameLimit = false;
+		}
+
 		// We can always vblank if VRR.
 		const bool bVRR = GetBackend()->GetCurrentConnector() && GetBackend()->GetCurrentConnector()->IsVRRActive();
 		if ( bVRR )
diff --git a/src/xwayland_ctx.hpp b/src/xwayland_ctx.hpp
index 407cd744256f..cc8118232e66 100644
--- a/src/xwayland_ctx.hpp
+++ b/src/xwayland_ctx.hpp
@@ -249,6 +249,8 @@ struct xwayland_ctx_t final : public gamescope::IWaitable
 		Atom clipboard;
 		Atom primarySelection;
 		Atom targets;
+
+		Atom gamescopeFrameHalveAtom;
 	} atoms;
 
 	bool HasQueuedEvents();
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Joshua Tam <297250+joshuatam@users.noreply.github.com>
Date: Fri, 6 Dec 2024 16:51:02 +0800
Subject: feat(intel): add rotation shader for rotating output

---
 src/Backends/DRMBackend.cpp  |  35 +++++++++-
 src/main.cpp                 |   7 ++
 src/main.hpp                 |   2 +
 src/meson.build              |   1 +
 src/rendervulkan.cpp         | 126 ++++++++++++++++++++++++++++++-----
 src/rendervulkan.hpp         |   6 +-
 src/shaders/cs_rotation.comp |  53 +++++++++++++++
 src/wlserver.cpp             |   5 ++
 8 files changed, 216 insertions(+), 19 deletions(-)
 create mode 100644 src/shaders/cs_rotation.comp

diff --git a/src/Backends/DRMBackend.cpp b/src/Backends/DRMBackend.cpp
index 0c97713955b7..b366f3592820 100644
--- a/src/Backends/DRMBackend.cpp
+++ b/src/Backends/DRMBackend.cpp
@@ -1609,6 +1609,10 @@ static void update_drm_effective_orientations( struct drm_t *drm, const drmModeM
 		if ( pDRMInternalConnector != drm->pConnector )
 			pInternalMode = find_mode( pDRMInternalConnector->GetModeConnector(), 0, 0, 0 );
 
+		if ( g_bUseRotationShader ) {
+			g_bEnableDRMRotationShader = true;
+		}
+
 		pDRMInternalConnector->UpdateEffectiveOrientation( pInternalMode );
 	}
 
@@ -1620,6 +1624,10 @@ static void update_drm_effective_orientations( struct drm_t *drm, const drmModeM
 		if ( pDRMExternalConnector != drm->pConnector )
 			pExternalMode = find_mode( pDRMExternalConnector->GetModeConnector(), 0, 0, 0 );
 
+		if ( g_bUseRotationShader ) {
+			g_bEnableDRMRotationShader = false;
+		}
+
 		pDRMExternalConnector->UpdateEffectiveOrientation( pExternalMode );
 	}
 }
@@ -1835,7 +1843,7 @@ LiftoffStateCacheEntry FrameInfoToLiftoffStateCacheEntry( struct drm_t *drm, con
 		uint64_t crtcW = srcWidth / frameInfo->layers[ i ].scale.x;
 		uint64_t crtcH = srcHeight / frameInfo->layers[ i ].scale.y;
 
-		if (g_bRotated)
+		if (g_bRotated && !g_bEnableDRMRotationShader)
 		{
 			int64_t imageH = frameInfo->layers[ i ].tex->contentHeight() / frameInfo->layers[ i ].scale.y;
 
@@ -2136,6 +2144,17 @@ namespace gamescope
 
 	void CDRMConnector::UpdateEffectiveOrientation( const drmModeModeInfo *pMode )
 	{
+		if (g_bEnableDRMRotationShader)
+		{
+			drm_log.infof("Using rotation shader");
+			if (g_DesiredInternalOrientation == GAMESCOPE_PANEL_ORIENTATION_270) {
+				m_ChosenOrientation = GAMESCOPE_PANEL_ORIENTATION_180;
+			} else {
+				m_ChosenOrientation = GAMESCOPE_PANEL_ORIENTATION_0;
+			}
+			return;
+		}
+        
 		if ( this->GetScreenType() == GAMESCOPE_SCREEN_TYPE_INTERNAL && g_DesiredInternalOrientation != GAMESCOPE_PANEL_ORIENTATION_AUTO )
 		{
 			m_ChosenOrientation = g_DesiredInternalOrientation;
@@ -3185,6 +3204,13 @@ bool drm_set_mode( struct drm_t *drm, const drmModeModeInfo *mode )
 		g_bRotated = false;
 		g_nOutputWidth = mode->hdisplay;
 		g_nOutputHeight = mode->vdisplay;
+
+		if (g_bEnableDRMRotationShader) {
+			g_bRotated = true;
+			g_nOutputWidth = mode->vdisplay;
+			g_nOutputHeight = mode->hdisplay;
+		}
+
 		break;
 	case GAMESCOPE_PANEL_ORIENTATION_90:
 	case GAMESCOPE_PANEL_ORIENTATION_270:
@@ -3449,6 +3475,11 @@ namespace gamescope
 
 			bNeedsFullComposite |= !!(g_uCompositeDebug & CompositeDebugFlag::Heatmap);
 
+			if (g_bEnableDRMRotationShader)
+			{
+				bNeedsFullComposite = true;
+			}
+
 			bool bDoComposite = true;
 			if ( !bNeedsFullComposite && !bWantsPartialComposite )
 			{
@@ -3539,7 +3570,7 @@ namespace gamescope
 			if ( bDefer && !!( g_uCompositeDebug & CompositeDebugFlag::Markers ) )
 				g_uCompositeDebug |= CompositeDebugFlag::Markers_Partial;
 
-			std::optional oCompositeResult = vulkan_composite( &compositeFrameInfo, nullptr, !bNeedsFullComposite );
+			std::optional oCompositeResult = vulkan_composite( &compositeFrameInfo, nullptr, !bNeedsFullComposite, nullptr, true, nullptr, g_bEnableDRMRotationShader );
 
 			m_bWasCompositing = true;
 
diff --git a/src/main.cpp b/src/main.cpp
index 531c8e806840..ba18187b6b26 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -134,6 +134,7 @@ const struct option *gamescope_options = (struct option[]){
 	{ "composite-debug", no_argument, nullptr, 0 },
 	{ "disable-xres", no_argument, nullptr, 'x' },
 	{ "fade-out-duration", required_argument, nullptr, 0 },
+	{ "use-rotation-shader", required_argument, nullptr, 0 },
 	{ "force-orientation", required_argument, nullptr, 0 },
 	{ "force-windows-fullscreen", no_argument, nullptr, 0 },
 	{ "custom-refresh-rates", required_argument, nullptr, 0 },
@@ -200,6 +201,7 @@ const char usage[] =
 	"  -e, --steam                    enable Steam integration\n"
 	"  --xwayland-count               create N xwayland servers\n"
 	"  --prefer-vk-device             prefer Vulkan device for compositing (ex: 1002:7300)\n"
+	"  --use-rotation-shader		  use rotation shader for rotating the screen\n"
 	"  --force-orientation            rotate the internal display (left, right, normal, upsidedown)\n"
 	"  --force-windows-fullscreen     force windows inside of gamescope to be the size of the nested display (fullscreen)\n"
 	"  --cursor-scale-height          if specified, sets a base output height to linearly scale the cursor against.\n"
@@ -365,6 +367,9 @@ static gamescope::GamescopeModeGeneration parse_gamescope_mode_generation( const
 	}
 }
 
+bool g_bUseRotationShader = false;
+bool g_bEnableDRMRotationShader = false;
+
 GamescopePanelOrientation g_DesiredInternalOrientation = GAMESCOPE_PANEL_ORIENTATION_AUTO;
 static GamescopePanelOrientation force_orientation(const char *str)
 {
@@ -822,6 +827,8 @@ int main(int argc, char **argv)
 					g_eGamescopeModeGeneration = parse_gamescope_mode_generation( optarg );
 				} else if (strcmp(opt_name, "force-orientation") == 0) {
 					g_DesiredInternalOrientation = force_orientation( optarg );
+                } else if (strcmp(opt_name, "use-rotation-shader") == 0) {
+					g_bUseRotationShader = true;
 				} else if (strcmp(opt_name, "custom-refresh-rates") == 0) {
 					g_customRefreshRates = parse_custom_refresh_rates( optarg );
 				} else if (strcmp(opt_name, "sharpness") == 0 ||
diff --git a/src/main.hpp b/src/main.hpp
index 390c04a63ecd..e7b857d44b0d 100644
--- a/src/main.hpp
+++ b/src/main.hpp
@@ -22,6 +22,8 @@ extern bool g_bForceRelativeMouse;
 extern int g_nOutputRefresh; // mHz
 extern bool g_bOutputHDREnabled;
 extern bool g_bForceInternal;
+extern bool g_bUseRotationShader;
+extern bool g_bEnableDRMRotationShader;
 
 extern bool g_bFullscreen;
 
diff --git a/src/meson.build b/src/meson.build
index 3650cdb3f8bc..12ad8d303235 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -72,6 +72,7 @@ shader_src = [
   'shaders/cs_nis.comp',
   'shaders/cs_nis_fp16.comp',
   'shaders/cs_rgb_to_nv12.comp',
+  'shaders/cs_rotation.comp',
 ]
 
 spirv_shaders = glsl_generator.process(shader_src)
diff --git a/src/rendervulkan.cpp b/src/rendervulkan.cpp
index f97b301542c7..c0b20b52fdd9 100644
--- a/src/rendervulkan.cpp
+++ b/src/rendervulkan.cpp
@@ -48,6 +48,7 @@
 #include "cs_nis.h"
 #include "cs_nis_fp16.h"
 #include "cs_rgb_to_nv12.h"
+#include "cs_rotation.h"
 
 #define A_CPU
 #include "shaders/ffx_a.h"
@@ -934,6 +935,7 @@ bool CVulkanDevice::createShaders()
 		SHADER(NIS, cs_nis);
 	}
 	SHADER(RGB_TO_NV12, cs_rgb_to_nv12);
+	SHADER(ROTATION, cs_rotation);
 #undef SHADER
 
 	for (uint32_t i = 0; i < shaderInfos.size(); i++)
@@ -1164,6 +1166,7 @@ void CVulkanDevice::compileAllPipelines()
 	SHADER(EASU, 1, 1, 1);
 	SHADER(NIS, 1, 1, 1);
 	SHADER(RGB_TO_NV12, 1, 1, 1);
+	SHADER(ROTATION, k_nMaxLayers, k_nMaxYcbcrMask_ToPreCompile, k_nMaxBlurLayers);
 #undef SHADER
 
 	for (auto& info : pipelineInfos) {
@@ -3265,8 +3268,16 @@ static bool vulkan_make_output_images( VulkanOutput_t *pOutput )
 
 	uint32_t uDRMFormat = pOutput->uOutputFormat;
 
+	uint32_t l_nOutputWidth = g_nOutputWidth;
+	uint32_t l_nOutputHeight = g_nOutputHeight;
+
+	if (g_bEnableDRMRotationShader) {
+		l_nOutputWidth = g_nOutputHeight;
+		l_nOutputHeight = g_nOutputWidth;
+	}
+
 	pOutput->outputImages[0] = new CVulkanTexture();
-	bool bSuccess = pOutput->outputImages[0]->BInit( g_nOutputWidth, g_nOutputHeight, 1u, uDRMFormat, outputImageflags );
+	bool bSuccess = pOutput->outputImages[0]->BInit( l_nOutputWidth, l_nOutputHeight, 1u, uDRMFormat, outputImageflags );
 	if ( bSuccess != true )
 	{
 		vk_log.errorf( "failed to allocate buffer for KMS" );
@@ -3274,7 +3285,7 @@ static bool vulkan_make_output_images( VulkanOutput_t *pOutput )
 	}
 
 	pOutput->outputImages[1] = new CVulkanTexture();
-	bSuccess = pOutput->outputImages[1]->BInit( g_nOutputWidth, g_nOutputHeight, 1u, uDRMFormat, outputImageflags );
+	bSuccess = pOutput->outputImages[1]->BInit( l_nOutputWidth, l_nOutputHeight, 1u, uDRMFormat, outputImageflags );
 	if ( bSuccess != true )
 	{
 		vk_log.errorf( "failed to allocate buffer for KMS" );
@@ -3282,7 +3293,7 @@ static bool vulkan_make_output_images( VulkanOutput_t *pOutput )
 	}
 
 	pOutput->outputImages[2] = new CVulkanTexture();
-	bSuccess = pOutput->outputImages[2]->BInit( g_nOutputWidth, g_nOutputHeight, 1u, uDRMFormat, outputImageflags );
+	bSuccess = pOutput->outputImages[2]->BInit( l_nOutputWidth, l_nOutputHeight, 1u, uDRMFormat, outputImageflags );
 	if ( bSuccess != true )
 	{
 		vk_log.errorf( "failed to allocate buffer for KMS" );
@@ -3297,7 +3308,7 @@ static bool vulkan_make_output_images( VulkanOutput_t *pOutput )
 		uint32_t uPartialDRMFormat = pOutput->uOutputFormatOverlay;
 
 		pOutput->outputImagesPartialOverlay[0] = new CVulkanTexture();
-		bool bSuccess = pOutput->outputImagesPartialOverlay[0]->BInit( g_nOutputWidth, g_nOutputHeight, 1u, uPartialDRMFormat, outputImageflags, nullptr, 0, 0, pOutput->outputImages[0].get() );
+		bool bSuccess = pOutput->outputImagesPartialOverlay[0]->BInit( l_nOutputWidth, l_nOutputHeight, 1u, uPartialDRMFormat, outputImageflags, nullptr, 0, 0, pOutput->outputImages[0].get() );
 		if ( bSuccess != true )
 		{
 			vk_log.errorf( "failed to allocate buffer for KMS" );
@@ -3305,7 +3316,7 @@ static bool vulkan_make_output_images( VulkanOutput_t *pOutput )
 		}
 
 		pOutput->outputImagesPartialOverlay[1] = new CVulkanTexture();
-		bSuccess = pOutput->outputImagesPartialOverlay[1]->BInit( g_nOutputWidth, g_nOutputHeight, 1u, uPartialDRMFormat, outputImageflags, nullptr, 0, 0, pOutput->outputImages[1].get() );
+		bSuccess = pOutput->outputImagesPartialOverlay[1]->BInit( l_nOutputWidth, l_nOutputHeight, 1u, uPartialDRMFormat, outputImageflags, nullptr, 0, 0, pOutput->outputImages[1].get() );
 		if ( bSuccess != true )
 		{
 			vk_log.errorf( "failed to allocate buffer for KMS" );
@@ -3313,7 +3324,7 @@ static bool vulkan_make_output_images( VulkanOutput_t *pOutput )
 		}
 
 		pOutput->outputImagesPartialOverlay[2] = new CVulkanTexture();
-		bSuccess = pOutput->outputImagesPartialOverlay[2]->BInit( g_nOutputWidth, g_nOutputHeight, 1u, uPartialDRMFormat, outputImageflags, nullptr, 0, 0, pOutput->outputImages[2].get() );
+		bSuccess = pOutput->outputImagesPartialOverlay[2]->BInit( l_nOutputWidth, l_nOutputHeight, 1u, uPartialDRMFormat, outputImageflags, nullptr, 0, 0, pOutput->outputImages[2].get() );
 		if ( bSuccess != true )
 		{
 			vk_log.errorf( "failed to allocate buffer for KMS" );
@@ -3443,6 +3454,28 @@ static void update_tmp_images( uint32_t width, uint32_t height )
 	}
 }
 
+static void update_rotated_images( uint32_t width, uint32_t height )
+{
+	if ( g_output.rotatedOutput != nullptr
+			&& width == g_output.rotatedOutput->width()
+			&& height == g_output.rotatedOutput->height() )
+	{
+		return;
+	}
+
+	CVulkanTexture::createFlags createFlags;
+	createFlags.bSampled = true;
+	createFlags.bStorage = true;
+
+	g_output.rotatedOutput = new CVulkanTexture();
+	bool bSuccess = g_output.rotatedOutput->BInit( width, height, 1u, DRM_FORMAT_ARGB8888, createFlags, nullptr );
+
+	if ( !bSuccess )
+	{
+		vk_log.errorf( "failed to create rotated output" );
+		return;
+	}
+}
 
 static bool init_nis_data()
 {
@@ -3928,7 +3961,7 @@ extern uint32_t g_reshade_technique_idx;
 
 ReshadeEffectPipeline *g_pLastReshadeEffect = nullptr;
 
-std::optional<uint64_t> vulkan_composite( struct FrameInfo_t *frameInfo, gamescope::Rc<CVulkanTexture> pPipewireTexture, bool partial, gamescope::Rc<CVulkanTexture> pOutputOverride, bool increment, std::unique_ptr<CVulkanCmdBuffer> pInCommandBuffer )
+std::optional<uint64_t> vulkan_composite( struct FrameInfo_t *frameInfo, gamescope::Rc<CVulkanTexture> pPipewireTexture, bool partial, gamescope::Rc<CVulkanTexture> pOutputOverride, bool increment, std::unique_ptr<CVulkanCmdBuffer> pInCommandBuffer, bool applyRotation )
 {
 	EOTF outputTF = frameInfo->outputEncodingEOTF;
 	if (!frameInfo->applyOutputColorMgmt)
@@ -4003,7 +4036,15 @@ std::optional<uint64_t> vulkan_composite( struct FrameInfo_t *frameInfo, gamesco
 		cmdBuffer->setTextureSrgb(0, true);
 		cmdBuffer->setSamplerUnnormalized(0, false);
 		cmdBuffer->setSamplerNearest(0, false);
-		cmdBuffer->bindTarget(compositeImage);
+
+		if (applyRotation) {
+			// Make a rotatedOutput with normal dimensions
+			update_rotated_images(currentOutputWidth, currentOutputHeight); // 2560x1600
+			cmdBuffer->bindTarget(g_output.rotatedOutput);
+		} else {
+			cmdBuffer->bindTarget(compositeImage);
+		}
+
 		cmdBuffer->uploadConstants<RcasPushData_t>(frameInfo, g_upscaleFilterSharpness / 10.0f);
 
 		cmdBuffer->dispatch(div_roundup(currentOutputWidth, pixelsPerGroup), div_roundup(currentOutputHeight, pixelsPerGroup));
@@ -4046,7 +4087,15 @@ std::optional<uint64_t> vulkan_composite( struct FrameInfo_t *frameInfo, gamesco
 
 		cmdBuffer->bindPipeline( g_device.pipeline(SHADER_TYPE_BLIT, nisFrameInfo.layerCount, nisFrameInfo.ycbcrMask(), 0u, nisFrameInfo.colorspaceMask(), outputTF ));
 		bind_all_layers(cmdBuffer.get(), &nisFrameInfo);
-		cmdBuffer->bindTarget(compositeImage);
+
+		if (applyRotation) {
+			// Make a rotatedOutput with normal dimensions
+			update_rotated_images(currentOutputWidth, currentOutputHeight); // 2560x1600
+			cmdBuffer->bindTarget(g_output.rotatedOutput);
+		} else {
+			cmdBuffer->bindTarget(compositeImage);
+		}
+
 		cmdBuffer->uploadConstants<BlitPushData_t>(&nisFrameInfo);
 
 		int pixelsPerGroup = 8;
@@ -4084,7 +4133,15 @@ std::optional<uint64_t> vulkan_composite( struct FrameInfo_t *frameInfo, gamesco
 		type = frameInfo->blurLayer0 == BLUR_MODE_COND ? SHADER_TYPE_BLUR_COND : SHADER_TYPE_BLUR;
 		cmdBuffer->bindPipeline(g_device.pipeline(type, frameInfo->layerCount, frameInfo->ycbcrMask(), blur_layer_count, frameInfo->colorspaceMask(), outputTF ));
 		bind_all_layers(cmdBuffer.get(), frameInfo);
-		cmdBuffer->bindTarget(compositeImage);
+
+		if (applyRotation) {
+			// Make a rotatedOutput with normal dimensions
+			update_rotated_images(currentOutputWidth, currentOutputHeight); // 2560x1600
+			cmdBuffer->bindTarget(g_output.rotatedOutput);
+		} else {
+			cmdBuffer->bindTarget(compositeImage);
+		}
+
 		cmdBuffer->bindTexture(VKR_BLUR_EXTRA_SLOT, g_output.tmpOutput);
 		cmdBuffer->setTextureSrgb(VKR_BLUR_EXTRA_SLOT, !useSrgbView); // Inverted because it chooses whether to view as linear (sRGB view) or sRGB (raw view). It's horrible. I need to change it.
 		cmdBuffer->setSamplerUnnormalized(VKR_BLUR_EXTRA_SLOT, true);
@@ -4094,14 +4151,51 @@ std::optional<uint64_t> vulkan_composite( struct FrameInfo_t *frameInfo, gamesco
 	}
 	else
 	{
-		cmdBuffer->bindPipeline( g_device.pipeline(SHADER_TYPE_BLIT, frameInfo->layerCount, frameInfo->ycbcrMask(), 0u, frameInfo->colorspaceMask(), outputTF ));
-		bind_all_layers(cmdBuffer.get(), frameInfo);
-		cmdBuffer->bindTarget(compositeImage);
-		cmdBuffer->uploadConstants<BlitPushData_t>(frameInfo);
+		if (applyRotation) {
+			cmdBuffer->bindPipeline( g_device.pipeline(SHADER_TYPE_ROTATION, frameInfo->layerCount, frameInfo->ycbcrMask(), 0u, frameInfo->colorspaceMask(), outputTF ));
+			bind_all_layers(cmdBuffer.get(), frameInfo);
+			cmdBuffer->bindTarget(compositeImage);
+			cmdBuffer->uploadConstants<BlitPushData_t>(frameInfo);
 
-		const int pixelsPerGroup = 8;
+			const int pixelsPerGroup = 8;
 
-		cmdBuffer->dispatch(div_roundup(currentOutputWidth, pixelsPerGroup), div_roundup(currentOutputHeight, pixelsPerGroup));
+			cmdBuffer->dispatch(div_roundup(currentOutputWidth, pixelsPerGroup), div_roundup(currentOutputHeight, pixelsPerGroup));
+		} else {
+			cmdBuffer->bindPipeline( g_device.pipeline(SHADER_TYPE_BLIT, frameInfo->layerCount, frameInfo->ycbcrMask(), 0u, frameInfo->colorspaceMask(), outputTF ));
+			bind_all_layers(cmdBuffer.get(), frameInfo);
+			cmdBuffer->bindTarget(compositeImage);
+			cmdBuffer->uploadConstants<BlitPushData_t>(frameInfo);
+
+			const int pixelsPerGroup = 8;
+
+			cmdBuffer->dispatch(div_roundup(currentOutputWidth, pixelsPerGroup), div_roundup(currentOutputHeight, pixelsPerGroup));
+		}
+	}
+
+	if (applyRotation)
+	{
+		if (g_output.rotatedOutput != nullptr) {
+			// Rotate the final output
+			// TODO: may need rework with another rotation shader for blur, fsr and nis
+			cmdBuffer->bindPipeline( g_device.pipeline(SHADER_TYPE_ROTATION, frameInfo->layerCount, frameInfo->ycbcrMask(), 0u, frameInfo->colorspaceMask(), outputTF));
+			bind_all_layers(cmdBuffer.get(), frameInfo);
+
+			// if (frameInfo->blurLayer0) {
+			// 	bool useSrgbView = frameInfo->layers[0].colorspace == GAMESCOPE_APP_TEXTURE_COLORSPACE_LINEAR;
+			//
+			// 	cmdBuffer->bindTexture(VKR_BLUR_EXTRA_SLOT, g_output.rotatedOutput);
+			// 	cmdBuffer->setTextureSrgb(VKR_BLUR_EXTRA_SLOT, !useSrgbView);
+			// 	cmdBuffer->setSamplerUnnormalized(VKR_BLUR_EXTRA_SLOT, true);
+			// 	cmdBuffer->setSamplerNearest(VKR_BLUR_EXTRA_SLOT, false);
+			// }
+
+			cmdBuffer->bindTarget(compositeImage);
+			cmdBuffer->uploadConstants<BlitPushData_t>(frameInfo);
+
+			const int pixelsPerGroup = 8;
+
+			cmdBuffer->dispatch(div_roundup(currentOutputWidth, pixelsPerGroup), div_roundup(currentOutputHeight, pixelsPerGroup));
+		}
 	}
 
 	if ( pPipewireTexture != nullptr )
diff --git a/src/rendervulkan.hpp b/src/rendervulkan.hpp
index 63cc6029ac5f..93a4a6027f55 100644
--- a/src/rendervulkan.hpp
+++ b/src/rendervulkan.hpp
@@ -408,7 +408,7 @@ gamescope::OwningRc<CVulkanTexture> vulkan_create_texture_from_dmabuf( struct wl
 gamescope::OwningRc<CVulkanTexture> vulkan_create_texture_from_bits( uint32_t width, uint32_t height, uint32_t contentWidth, uint32_t contentHeight, uint32_t drmFormat, CVulkanTexture::createFlags texCreateFlags, void *bits );
 gamescope::OwningRc<CVulkanTexture> vulkan_create_texture_from_wlr_buffer( struct wlr_buffer *buf, gamescope::OwningRc<gamescope::IBackendFb> pBackendFb );
 
-std::optional<uint64_t> vulkan_composite( struct FrameInfo_t *frameInfo, gamescope::Rc<CVulkanTexture> pScreenshotTexture, bool partial, gamescope::Rc<CVulkanTexture> pOutputOverride = nullptr, bool increment = true, std::unique_ptr<CVulkanCmdBuffer> pInCommandBuffer = nullptr );
+std::optional<uint64_t> vulkan_composite( struct FrameInfo_t *frameInfo, gamescope::Rc<CVulkanTexture> pScreenshotTexture, bool partial, gamescope::Rc<CVulkanTexture> pOutputOverride = nullptr, bool increment = true, std::unique_ptr<CVulkanCmdBuffer> pInCommandBuffer = nullptr, bool applyRotation = false );
 void vulkan_wait( uint64_t ulSeqNo, bool bReset );
 gamescope::Rc<CVulkanTexture> vulkan_get_last_output_image( bool partial, bool defer );
 gamescope::Rc<CVulkanTexture> vulkan_acquire_screenshot_texture(uint32_t width, uint32_t height, bool exportable, uint32_t drmFormat, EStreamColorspace colorspace = k_EStreamColorspace_Unknown);
@@ -545,6 +545,9 @@ struct VulkanOutput_t
 	// NIS
 	gamescope::OwningRc<CVulkanTexture> nisScalerImage;
 	gamescope::OwningRc<CVulkanTexture> nisUsmImage;
+
+	// Rotated
+	gamescope::OwningRc<CVulkanTexture> rotatedOutput;
 };
 
 
@@ -557,6 +560,7 @@ enum ShaderType {
 	SHADER_TYPE_RCAS,
 	SHADER_TYPE_NIS,
 	SHADER_TYPE_RGB_TO_NV12,
+	SHADER_TYPE_ROTATION,
 
 	SHADER_TYPE_COUNT
 };
diff --git a/src/shaders/cs_rotation.comp b/src/shaders/cs_rotation.comp
new file mode 100644
index 000000000000..1a47fd505748
--- /dev/null
+++ b/src/shaders/cs_rotation.comp
@@ -0,0 +1,53 @@
+#version 450
+
+#extension GL_GOOGLE_include_directive : require
+#extension GL_EXT_scalar_block_layout : require
+
+#include "descriptor_set.h"
+
+layout(
+    local_size_x = 8,
+    local_size_y = 8,
+    local_size_z = 1) in;
+
+#include "blit_push_data.h"
+#include "composite.h"
+
+vec4 sampleLayer(uint layerIdx, vec2 uv) {
+    if ((c_ycbcrMask & (1 << layerIdx)) != 0)
+        return sampleLayer(s_ycbcr_samplers[layerIdx], layerIdx, uv, false);
+    return sampleLayer(s_samplers[layerIdx], layerIdx, uv, true);
+}
+
+void main() {
+    uvec2 coord = uvec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
+    uvec2 outSize = imageSize(dst);
+    float outWidth = outSize.y;
+    float outHeight = outSize.x;
+
+    vec2 uv = vec2(coord);
+    vec4 outputValue = vec4(255.0f);
+
+    if (c_layerCount > 0) {
+        outputValue = sampleLayer(0, uv) * u_opacity[0];
+    }
+
+    for (int i = 1; i < c_layerCount; i++) {
+        vec4 layerColor = sampleLayer(i, uv);
+        // wl_surfaces come with premultiplied alpha, so that's them being
+        // premultiplied by layerColor.a.
+        // We need to then multiply that by the layer's opacity to get to our
+        // final premultiplied state.
+        // For the other side of things, we need to multiply by (1.0f - (layerColor.a * opacity))
+        float opacity = u_opacity[i];
+        float layerAlpha = opacity * layerColor.a;
+        outputValue = layerColor * opacity + outputValue * (1.0f - layerAlpha);
+    }
+
+    outputValue.rgb = encodeOutputColor(outputValue.rgb);
+
+    // Rotate the pixel coordinates counter-clockwise by 90 degrees
+    ivec2 rotatedCoord = ivec2(coord.y, outWidth - coord.x - 1);
+
+    imageStore(dst, rotatedCoord, outputValue);
+}
diff --git a/src/wlserver.cpp b/src/wlserver.cpp
index b154bd40d7fd..2747c7314e56 100644
--- a/src/wlserver.cpp
+++ b/src/wlserver.cpp
@@ -2838,6 +2838,11 @@ static void apply_touchscreen_orientation(GamescopePanelOrientation orientation,
 			break;
 	}
 
+	if (g_bEnableDRMRotationShader) {
+		tx = 1.0 - *y;
+		ty = *x;
+	}
+
 	*x = tx;
 	*y = ty;
 }
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: brainantifreeze <you@example.com>
Date: Thu, 19 Dec 2024 09:16:15 +0000
Subject: feat(nvidia): fix crash with current driver

add layer env var to hide present wait ext

see: https://github.com/ValveSoftware/gamescope/pull/1671
---
 layer/VkLayer_FROG_gamescope_wsi.cpp | 20 +++++++++++++++++++-
 1 file changed, 19 insertions(+), 1 deletion(-)

diff --git a/layer/VkLayer_FROG_gamescope_wsi.cpp b/layer/VkLayer_FROG_gamescope_wsi.cpp
index af0c2009930b..263cbc37bd88 100644
--- a/layer/VkLayer_FROG_gamescope_wsi.cpp
+++ b/layer/VkLayer_FROG_gamescope_wsi.cpp
@@ -183,6 +183,16 @@ namespace GamescopeWSILayer {
     return s_ensureMinImageCount;
   }
 
+  static bool getHidePresentWait() {
+    static bool s_hidePresentWait = []() -> bool {
+      if (auto hide = parseEnv<bool>("GAMESCOPE_WSI_HIDE_PRESENT_WAIT_EXT")) {
+        return *hide;
+      }
+      return false;
+    }();
+    return s_hidePresentWait;
+  }
+
   // Taken from Mesa, licensed under MIT.
   //
   // No real reason to rewrite this code,
@@ -589,7 +599,11 @@ namespace GamescopeWSILayer {
       createInfo.ppEnabledExtensionNames = enabledExts.data();
 
       setenv("vk_xwayland_wait_ready", "false", 0);
-      setenv("vk_khr_present_wait", "true", 0);
+      if (getHidePresentWait()) {
+        setenv("vk_khr_present_wait", "false", 0);
+      } else {
+        setenv("vk_khr_present_wait", "true", 0);
+      }
 
       VkResult result = pfnCreateInstanceProc(&createInfo, pAllocator, pInstance);
       if (result != VK_SUCCESS)
@@ -899,6 +913,10 @@ namespace GamescopeWSILayer {
       const vkroots::VkInstanceDispatch* pDispatch,
             VkPhysicalDevice             physicalDevice,
             VkPhysicalDeviceFeatures2*   pFeatures) {
+      if (getHidePresentWait()) {
+        fprintf(stderr, "[Gamescope WSI] Removing VkPhysicalDevicePresentWaitFeaturesKHR because GAMESCOPE_WSI_HIDE_PRESENT_WAIT_EXT is set\n");
+        vkroots::RemoveFromChain<VkPhysicalDevicePresentWaitFeaturesKHR>(pFeatures);
+      }
       pDispatch->GetPhysicalDeviceFeatures2(physicalDevice, pFeatures);
     }
 
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <git@antheas.dev>
Date: Sun, 23 Feb 2025 02:16:55 +0100
Subject: feat(display): add asus z13

---
 .../00-gamescope/displays/asus.z13.lcd.lua    | 57 +++++++++++++++++++
 1 file changed, 57 insertions(+)
 create mode 100644 scripts/00-gamescope/displays/asus.z13.lcd.lua

diff --git a/scripts/00-gamescope/displays/asus.z13.lcd.lua b/scripts/00-gamescope/displays/asus.z13.lcd.lua
new file mode 100644
index 000000000000..891f1ea9ca6f
--- /dev/null
+++ b/scripts/00-gamescope/displays/asus.z13.lcd.lua
@@ -0,0 +1,57 @@
+gamescope.config.known_displays.asusz13_lcd = {
+    pretty_name = "Asus Z13 LCD",
+    dynamic_refresh_rates = {
+        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 
+        65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 
+        82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 
+        99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 
+        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 
+        127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 
+        141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 
+        155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 
+        169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180
+    },
+    
+    -- Detailed Timing Descriptors:
+    -- DTD 1:  1920x1200  120.002 Hz   8:5   151.683 kHz 315.500 MHz (172 mm x 107 mm)
+    --   Modeline "1920x1200_120.00" 315.500  1920 1968 2000 2080  1200 1254 1260 1264  -HSync -VSync
+    -- DTD 2:  1920x1200   60.001 Hz   8:5    75.841 kHz 157.750 MHz (172 mm x 107 mm)
+    --   Modeline "1920x1200_60.00" 157.750  1920 1968 2000 2080  1200 1254 1260 1264  -HSync -VSync
+    dynamic_modegen = function(base_mode, refresh)
+        debug("Generating mode "..refresh.."Hz with fixed pixel clock")
+        local vfps = {
+            4886, 4751, 4620, 4495, 4375, 4259, 4147, 4040, 3936, 3836, 3739, 3646, 
+            3556, 3468, 3384, 3302, 3223, 3146, 3072, 2999, 2929, 2861, 2795, 2731, 
+            2668, 2608, 2548, 2491, 2435, 2380, 2327, 2275, 2225, 2175, 2127, 2080, 
+            2035, 1990, 1946, 1903, 1862, 1821, 1781, 1742, 1704, 1667, 1630, 1594, 
+            1559, 1525, 1491, 1458, 1426, 1395, 1364, 1333, 1303, 1274, 1245, 1217, 
+            1190, 1162, 1136, 1110, 1084, 1059, 1034, 1010, 986, 962, 939, 916, 894,
+            872, 850, 829, 808, 787, 767, 747, 727, 708, 689, 670, 652, 634, 616, 
+            598, 581, 563, 547, 530, 513, 497, 481, 466, 450, 435, 420, 405, 390, 
+            376, 361, 347, 333, 320, 306, 293, 279, 266, 254, 241, 228, 216, 204, 
+            192, 180, 168, 156, 145, 133, 122, 111, 100, 89, 78, 68, 57, 47, 36, 
+            26, 16, 6
+        }
+        local vfp = vfps[zero_index(refresh - 48)]
+        if vfp == nil then
+            warn("Couldn't do refresh "..refresh.." on ROG Ally")
+            return base_mode
+        end
+
+        local mode = base_mode
+
+        gamescope.modegen.adjust_front_porch(mode, vfp)
+        mode.vrefresh = gamescope.modegen.calc_vrefresh(mode)
+
+        --debug(inspect(mode))
+        return mode
+    end,
+    matches = function(display)
+        if display.vendor == "TMA" and display.model == "TL134ADXP03" then
+            debug("[z13] Matched vendor: "..display.vendor.." model: "..display.model.." product:"..display.product)
+            return 5000
+        end
+        return -1
+    end
+}
+debug("Registered Lenovo Legion Go S LCD as a known display")
\ No newline at end of file
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <git@antheas.dev>
Date: Wed, 23 Apr 2025 22:51:54 +0200
Subject: feat(display): consider vporch to avoid timing issues

---
 src/Backends/DRMBackend.cpp | 8 ++++++++
 src/main.cpp                | 1 +
 src/main.hpp                | 1 +
 src/vblankmanager.cpp       | 6 +-----
 4 files changed, 11 insertions(+), 5 deletions(-)

diff --git a/src/Backends/DRMBackend.cpp b/src/Backends/DRMBackend.cpp
index b366f3592820..dd64d28cfc0e 100644
--- a/src/Backends/DRMBackend.cpp
+++ b/src/Backends/DRMBackend.cpp
@@ -213,6 +213,11 @@ namespace gamescope
 		return nRefresh;
 	}
 
+	static int32_t GetVblankNs(const drmModeModeInfo *mode)
+	{
+		return (mode->vsync_start - mode->vdisplay) * 1'000'000'000ll / mode->vrefresh / mode->vtotal;
+	}
+
 	template <typename T>
 	using CAutoDeletePtr = std::unique_ptr<T, void(*)(T*)>;
 
@@ -3194,6 +3199,9 @@ bool drm_set_mode( struct drm_t *drm, const drmModeModeInfo *mode )
 	g_nOutputRefresh = gamescope::GetModeRefresh( mode );
 	g_nDynamicRefreshHz = 0;
 
+	g_nsVsync = gamescope::GetVblankNs( mode );
+	drm_log.infof("Vblank ns: %lu", g_nsVsync);
+
 	update_drm_effective_orientations(drm, mode);
 
 	switch ( drm->pConnector->GetCurrentOrientation() )
diff --git a/src/main.cpp b/src/main.cpp
index ba18187b6b26..bdc9a5e0de3c 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -301,6 +301,7 @@ int g_nNestedDisplayIndex = 0;
 uint32_t g_nOutputWidth = 0;
 uint32_t g_nOutputHeight = 0;
 int g_nOutputRefresh = 0;
+long g_nsVsync = 0;
 bool g_bOutputHDREnabled = false;
 
 bool g_bFullscreen = false;
diff --git a/src/main.hpp b/src/main.hpp
index e7b857d44b0d..e6f8ff133689 100644
--- a/src/main.hpp
+++ b/src/main.hpp
@@ -20,6 +20,7 @@ extern uint32_t g_nOutputWidth;
 extern uint32_t g_nOutputHeight;
 extern bool g_bForceRelativeMouse;
 extern int g_nOutputRefresh; // mHz
+extern long g_nsVsync;       // ns
 extern bool g_bOutputHDREnabled;
 extern bool g_bForceInternal;
 extern bool g_bUseRotationShader;
diff --git a/src/vblankmanager.cpp b/src/vblankmanager.cpp
index f036d000a8e2..e388374c98ba 100644
--- a/src/vblankmanager.cpp
+++ b/src/vblankmanager.cpp
@@ -95,8 +95,6 @@ namespace gamescope
 
 	VBlankScheduleTime CVBlankTimer::CalcNextWakeupTime( bool bPreemptive )
 	{
-		const GamescopeScreenType eScreenType = GetBackend()->GetScreenType();
-
 		const int nRefreshRate = GetRefresh();
 		const uint64_t ulRefreshInterval = mHzToRefreshCycle( nRefreshRate );
 
@@ -113,9 +111,7 @@ namespace gamescope
 			// to not account for vertical front porch when dealing with the vblank
 			// drm_commit is going to target?
 			// Need to re-test that.
-			const uint64_t ulRedZone = eScreenType == GAMESCOPE_SCREEN_TYPE_INTERNAL
-				? m_ulVBlankDrawBufferRedZone
-				: std::min<uint64_t>( m_ulVBlankDrawBufferRedZone, ( m_ulVBlankDrawBufferRedZone * 60'000 * nRefreshRate ) / 60'000 );
+			const uint64_t ulRedZone = m_ulVBlankDrawBufferRedZone + g_nsVsync;
 
 			const uint64_t ulDecayAlpha = m_ulVBlankRateOfDecayPercentage; // eg. 980 = 98%
 
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <git@antheas.dev>
Date: Sun, 22 Jun 2025 15:18:19 +0200
Subject: feat: add Legion Go S display with all framerates

---
 .../displays/lenovo.legiongos.lcd.lua         | 71 +++++++++++--------
 1 file changed, 42 insertions(+), 29 deletions(-)

diff --git a/scripts/00-gamescope/displays/lenovo.legiongos.lcd.lua b/scripts/00-gamescope/displays/lenovo.legiongos.lcd.lua
index 32f776c17f3d..057850f374f8 100644
--- a/scripts/00-gamescope/displays/lenovo.legiongos.lcd.lua
+++ b/scripts/00-gamescope/displays/lenovo.legiongos.lcd.lua
@@ -1,44 +1,58 @@
-local legiongos_lcd_refresh_rates = {
-    52, 53, 54, 56, 57, 58, 59,
-    60, 61, 62, 63, 64, 65, 67, 68, 69,
-    70,
-    102, 103, 104, 105, 106, 107, 108, 109,
-    111, 112, 113, 114, 115, 116, 117, 118, 119,
-    120
-}
-
 gamescope.config.known_displays.legiongos_lcd = {
     pretty_name = "Lenovo Legion Go S LCD",
     hdr = {
-        -- The Legion Go S panel does not support HDR.
+        -- Setup some fallbacks for undocking with HDR, meant
+        -- for the internal panel. It does not support HDR.
         supported = false,
         force_enabled = false,
-            eotf = gamescope.eotf.gamma22,
-            max_content_light_level = 500,
-            max_frame_average_luminance = 500,
-            min_content_light_level = 0.5
+        eotf = gamescope.eotf.gamma22,
+        max_content_light_level = 500,
+        max_frame_average_luminance = 500,
+        min_content_light_level = 0.5
     },
-    -- 60Hz has a different pixel clock than 120Hz in the EDID with VRR disabled,
-    -- and the panel is not responsive to tuning VFPs. To cover the non-VRR
-    -- limiter, an LCD Deck-style dynamic modegen method works best.
-    dynamic_refresh_rates = legiongos_lcd_refresh_rates,
+    
+    dynamic_refresh_rates = {
+        48, 49, 50, 51, 52, 53, 54, 55, 56, 57,
+        58, 59, 60, 61, 62, 63, 64, 65, 66, 67,
+        68, 69, 70, 71, 72, 73, 74, 75, 76, 77,
+        78, 79, 80, 81, 82, 83, 84, 85, 86, 87,
+        88, 89, 90, 91, 92, 93, 94, 95, 96, 97,
+        98, 99, 100, 101, 102, 103, 104, 105, 106, 107,
+        108, 109, 110, 111, 112, 113, 114, 115, 116, 117,
+        118, 119, 120
+    },
+    
+    -- Detailed Timing Descriptors:
+    -- DTD 1:  1920x1200  120.002 Hz   8:5   151.683 kHz 315.500 MHz (172 mm x 107 mm)
+    --   Modeline "1920x1200_120.00" 315.500  1920 1968 2000 2080  1200 1254 1260 1264  -HSync -VSync
+    -- DTD 2:  1920x1200   60.001 Hz   8:5    75.841 kHz 157.750 MHz (172 mm x 107 mm)
+    --   Modeline "1920x1200_60.00" 157.750  1920 1968 2000 2080  1200 1254 1260 1264  -HSync -VSync
     dynamic_modegen = function(base_mode, refresh)
-        debug("Generating mode "..refresh.."Hz for Lenovo Legion Go S LCD")
-        local mode = base_mode
+        debug("Generating mode "..refresh.."Hz with fixed pixel clock")
+        local vfps = {
+            1950, 1885, 1824, 1764, 1707, 1652, 1599, 1548, 1499, 1451, 1405,
+            1361, 1318, 1277, 1237, 1198, 1160, 1124, 1088, 1054, 1021, 988,
+            957, 927, 897, 868, 840, 813, 786, 760, 735, 710, 686, 663, 640,
+            618, 596, 575, 554, 534, 514, 495, 476, 457, 439, 421, 404, 387,
+            370, 354, 338, 322, 307, 292, 277, 263, 249, 235, 221, 208, 195,
+            182, 169, 157, 145, 133, 121, 109, 98, 87, 76, 65, 54
+        }
+        local vfp = vfps[zero_index(refresh - 48)]
+        if vfp == nil then
+            warn("Couldn't do refresh "..refresh.." on ROG Ally")
+            return base_mode
+        end
 
-        -- These are only tuned for 1920x1200.
-        gamescope.modegen.set_resolution(mode, 1920, 1200)
+        local mode = base_mode
 
-        -- hfp, hsync, hbp
-        gamescope.modegen.set_h_timings(mode, 48, 36, 80)
-        -- vfp, vsync, vbp
-        gamescope.modegen.set_v_timings(mode, 54, 6, 4)
-        mode.clock = gamescope.modegen.calc_max_clock(mode, refresh)
+        gamescope.modegen.adjust_front_porch(mode, vfp)
         mode.vrefresh = gamescope.modegen.calc_vrefresh(mode)
 
         --debug(inspect(mode))
         return mode
     end,
+
+    
     matches = function(display)
         local lcd_types = {
             { vendor = "CSW", model = "PN8007QB1-1", product = 0x0800 },
@@ -56,5 +70,4 @@ gamescope.config.known_displays.legiongos_lcd = {
         return -1
     end
 }
-debug("Registered Lenovo Legion Go S LCD as a known display")
---debug(inspect(gamescope.config.known_displays.legiongos_lcd))
+debug("Registered Lenovo Legion Go S LCD as a known display")
\ No newline at end of file
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <git@antheas.dev>
Date: Fri, 29 Aug 2025 16:45:39 +0200
Subject: feat: add DPMS support through an Atom

---
 src/Backends/DRMBackend.cpp | 15 ++++++++++++++-
 src/rendervulkan.hpp        |  2 ++
 src/steamcompmgr.cpp        | 18 +++++++++++++++---
 src/xwayland_ctx.hpp        |  1 +
 4 files changed, 32 insertions(+), 4 deletions(-)

diff --git a/src/Backends/DRMBackend.cpp b/src/Backends/DRMBackend.cpp
index dd64d28cfc0e..a3dcc46e0ec9 100644
--- a/src/Backends/DRMBackend.cpp
+++ b/src/Backends/DRMBackend.cpp
@@ -2827,6 +2827,9 @@ int drm_prepare( struct drm_t *drm, bool async, const struct FrameInfo_t *frameI
 			drm->needs_modeset = true;
 	}
 
+	if (drm->pCRTC && drm->pCRTC->GetProperties().ACTIVE->GetCurrentValue() != !frameInfo->dpms)
+		drm->needs_modeset = true;
+
 	drm_colorspace uColorimetry = DRM_MODE_COLORIMETRY_DEFAULT;
 
 	const bool bWantsHDR10 = g_bOutputHDREnabled && frameInfo->outputEncodingEOTF == EOTF_PQ;
@@ -2894,6 +2897,9 @@ int drm_prepare( struct drm_t *drm, bool async, const struct FrameInfo_t *frameI
 			needs_modeset = true;
 	}
 
+	if ( frameInfo->dpms )
+		bSleep = true;
+
 	if ( !bSleep )
 	{
 		if ( drm->pCRTC != nullptr )
@@ -2973,7 +2979,13 @@ int drm_prepare( struct drm_t *drm, bool async, const struct FrameInfo_t *frameI
 
 		if ( drm->pCRTC && !bSleep )
 		{
-			drm->pCRTC->GetProperties().ACTIVE->SetPendingValue( drm->req, 1u, true );
+			if ( frameInfo->dpms ) {
+				// We can't disable a CRTC if it's already disabled
+				if (drm->pCRTC->GetProperties().ACTIVE->GetCurrentValue() != 0)
+					drm->pCRTC->GetProperties().ACTIVE->SetPendingValue(drm->req, 0, true);
+			}
+			else
+				drm->pCRTC->GetProperties().ACTIVE->SetPendingValue( drm->req, 1u, true );
 			drm->pCRTC->GetProperties().MODE_ID->SetPendingValue( drm->req, drm->pending.mode_id ? drm->pending.mode_id->GetBlobValue() : 0lu, true );
 
 			if ( drm->pCRTC->GetProperties().VRR_ENABLED )
@@ -3594,6 +3606,7 @@ namespace gamescope
 
 			FrameInfo_t presentCompFrameInfo = {};
 			presentCompFrameInfo.allowVRR = pFrameInfo->allowVRR;
+			presentCompFrameInfo.dpms = pFrameInfo->dpms;
 			presentCompFrameInfo.outputEncodingEOTF = pFrameInfo->outputEncodingEOTF;
 
 			if ( bNeedsFullComposite )
diff --git a/src/rendervulkan.hpp b/src/rendervulkan.hpp
index 93a4a6027f55..0833fc46ffd7 100644
--- a/src/rendervulkan.hpp
+++ b/src/rendervulkan.hpp
@@ -292,6 +292,8 @@ struct FrameInfo_t
 	bool applyOutputColorMgmt; // drm only
 	EOTF outputEncodingEOTF;
 
+	bool dpms;
+
 	int layerCount;
 	struct Layer_t
 	{
diff --git a/src/steamcompmgr.cpp b/src/steamcompmgr.cpp
index bf7ae6cad13e..0fae5ac9fdb0 100644
--- a/src/steamcompmgr.cpp
+++ b/src/steamcompmgr.cpp
@@ -177,6 +177,8 @@ bool g_bSteamIsActiveWindow = false;
 bool g_bForceInternal = false;
 bool b_bForceFrameLimit = false;
 bool g_bRefreshHalveEnable = false;
+bool g_bDPMS = false;
+bool g_bDPMS_set = false;
 
 namespace gamescope
 {
@@ -2462,7 +2464,7 @@ gamescope::ConVar<bool> cv_paint_cursor_plane{ "paint_cursor_plane", true };
 gamescope::ConVar<bool> cv_paint_mura_plane{ "paint_mura_plane", true };
 
 static void
-paint_all( global_focus_t *pFocus, bool async )
+paint_all(global_focus_t *pFocus, bool async, bool dpms)
 {
 	if ( !pFocus )
 		return;
@@ -2520,6 +2522,7 @@ paint_all( global_focus_t *pFocus, bool async )
 	frameInfo.outputEncodingEOTF = g_ColorMgmt.pending.outputEncodingEOTF;
 	frameInfo.allowVRR = cv_adaptive_sync;
 	frameInfo.bFadingOut = fadingOut;
+	frameInfo.dpms = dpms;
 
 	// If the window we'd paint as the base layer is the streaming client,
 	// find the video underlay and put it up first in the scenegraph
@@ -6347,6 +6350,10 @@ handle_property_notify(xwayland_ctx_t *ctx, XPropertyEvent *ev)
 	{
 		g_bRefreshHalveEnable = !!get_prop( ctx, ctx->root, ctx->atoms.gamescopeFrameHalveAtom, 0 );
 	}
+	if (ev->atom == ctx->atoms.gamescopeDPMS)
+	{
+		g_bDPMS = !!get_prop(ctx, ctx->root, ctx->atoms.gamescopeDPMS, 0);
+	}
 }
 
 static int
@@ -7593,6 +7600,7 @@ void init_xwayland_ctx(uint32_t serverId, gamescope_xwayland_server_t *xwayland_
 	ctx->atoms.targets = XInternAtom(ctx->dpy, "TARGETS", false);
 
 	ctx->atoms.gamescopeFrameHalveAtom = XInternAtom( ctx->dpy, "GAMESCOPE_STEAMUI_HALFHZ", false );;
+	ctx->atoms.gamescopeDPMS = XInternAtom(ctx->dpy, "GAMESCOPE_DPMS", false);
 
 	ctx->root_width = DisplayWidth(ctx->dpy, ctx->scr);
 	ctx->root_height = DisplayHeight(ctx->dpy, ctx->scr);
@@ -8761,10 +8769,14 @@ steamcompmgr_main(int argc, char **argv)
 				bShouldPaint = false;
 			}
 
+			if ( g_bDPMS != g_bDPMS_set && vblank )
+				bShouldPaint = true;
+
 			if ( bShouldPaint )
 			{
-				paint_all( pPaintFocus, eFlipType == FlipType::Async );
-
+				paint_all( pPaintFocus, eFlipType == FlipType::Async, g_bDPMS );
+				
+				g_bDPMS_set = g_bDPMS;
 				bPainted = true;
 			}
 		}
diff --git a/src/xwayland_ctx.hpp b/src/xwayland_ctx.hpp
index cc8118232e66..a81dae2d61e5 100644
--- a/src/xwayland_ctx.hpp
+++ b/src/xwayland_ctx.hpp
@@ -251,6 +251,7 @@ struct xwayland_ctx_t final : public gamescope::IWaitable
 		Atom targets;
 
 		Atom gamescopeFrameHalveAtom;
+		Atom gamescopeDPMS;
 	} atoms;
 
 	bool HasQueuedEvents();
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <git@antheas.dev>
Date: Sun, 29 Jun 2025 13:16:59 +0200
Subject: update misyltoad urls

---
 .gitmodules | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/.gitmodules b/.gitmodules
index ec7d4e430ee8..17ba783f809b 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,12 +1,12 @@
 [submodule "subprojects/wlroots"]
 	path = subprojects/wlroots
-	url = https://github.com/Joshua-Ashton/wlroots.git
+	url = https://github.com/misyltoad/wlroots.git
 [submodule "subprojects/libliftoff"]
 	path = subprojects/libliftoff
 	url = https://gitlab.freedesktop.org/emersion/libliftoff.git
 [submodule "subprojects/vkroots"]
 	path = subprojects/vkroots
-	url = https://github.com/Joshua-Ashton/vkroots
+	url = https://github.com/misyltoad/vkroots
 [submodule "subprojects/libdisplay-info"]
 	path = subprojects/libdisplay-info
 	url = https://gitlab.freedesktop.org/emersion/libdisplay-info
@@ -15,7 +15,7 @@
 	url = https://github.com/ValveSoftware/openvr.git
 [submodule "src/reshade"]
 	path = src/reshade
-	url = https://github.com/Joshua-Ashton/reshade
+	url = https://github.com/misyltoad/reshade
 [submodule "thirdparty/SPIRV-Headers"]
 	path = thirdparty/SPIRV-Headers
 	url = https://github.com/KhronosGroup/SPIRV-Headers/
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <git@antheas.dev>
Date: Fri, 29 Aug 2025 15:31:34 +0200
Subject: fix: drain timer fds to avoid epoll_wait returning constantly

Currently, if the VBlank or VRR timers expire without being rescheduled,
their FDs remain readable, causing epoll_wait to return instantly.|Drain
the FDs in the OnPollIn handlers to prevent this.
---
 src/waitable.h | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/src/waitable.h b/src/waitable.h
index 30edf8f52deb..36ac61ee7233 100644
--- a/src/waitable.h
+++ b/src/waitable.h
@@ -182,6 +182,11 @@ namespace gamescope
             ArmTimer( 0ul, false );
         }
 
+        void OnPollIn()
+        {
+            IWaitable::Drain(m_nFD);
+        }
+
         int GetFD()
         {
             return m_nFD;
@@ -200,6 +205,7 @@ namespace gamescope
 
         void OnPollIn() final
         {
+            ITimerWaitable::OnPollIn();
             m_fnPollFunc();
         }
     private:
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <git@antheas.dev>
Date: Sat, 30 Aug 2025 15:12:39 +0200
Subject: fix(intel): allow night mode and color adjustment via compositing

---
 src/Backends/DRMBackend.cpp | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/src/Backends/DRMBackend.cpp b/src/Backends/DRMBackend.cpp
index a3dcc46e0ec9..dec04e831986 100644
--- a/src/Backends/DRMBackend.cpp
+++ b/src/Backends/DRMBackend.cpp
@@ -3481,6 +3481,17 @@ namespace gamescope
 			bNeedsFullComposite |= pFrameInfo->bFadingOut;
 			bNeedsFullComposite |= !g_reshade_effect.empty();
 
+			if ( !SupportsColorManagement() ) {
+				// Fuzzy match default values to see if we need to composite
+				bNeedsFullComposite |= g_ColorMgmt.pending.nightmode.amount != 0.0f;
+				bNeedsFullComposite |= g_ColorMgmt.pending.outputVirtualWhite.x > 0 &&
+					abs(g_ColorMgmt.pending.outputVirtualWhite.x - 0.3127f) > 0.001f;
+				bNeedsFullComposite |= g_ColorMgmt.pending.outputVirtualWhite.y > 0 &&
+					abs(g_ColorMgmt.pending.outputVirtualWhite.y - 0.3290f) > 0.001f;
+				bNeedsFullComposite |= g_ColorMgmt.pending.sdrGamutWideness >= 0 &&
+					abs(g_ColorMgmt.pending.sdrGamutWideness - 0.5f) > 0.02f;
+			}
+
 			if ( g_bOutputHDREnabled )
 			{
 				bNeedsFullComposite |= g_bHDRItmEnable;
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <git@antheas.dev>
Date: Sat, 30 Aug 2025 15:32:00 +0200
Subject: fix(hdr): disable PQ on handheld internal displays

For some reason, the PQ transfer function does not work on current
handhelds. So use gamma 22 instead. This allows us to skip creating
configs and read the HDR metadata from the displays.
---
 src/Backends/DRMBackend.cpp | 8 +++++++-
 src/backend.h               | 1 +
 src/main.cpp                | 3 +++
 src/steamcompmgr.cpp        | 4 ++++
 4 files changed, 15 insertions(+), 1 deletion(-)

diff --git a/src/Backends/DRMBackend.cpp b/src/Backends/DRMBackend.cpp
index dec04e831986..b9b3fd160b75 100644
--- a/src/Backends/DRMBackend.cpp
+++ b/src/Backends/DRMBackend.cpp
@@ -2465,7 +2465,13 @@ namespace gamescope
 				 pHDRStaticMetadata && pHDRStaticMetadata->eotfs && pHDRStaticMetadata->eotfs->pq )
 			{
 				m_Mutable.HDR.bExposeHDRSupport = true;
-				m_Mutable.HDR.eOutputEncodingEOTF = EOTF_PQ;
+				if (disableInternalPq && GetScreenType() == GAMESCOPE_SCREEN_TYPE_INTERNAL)
+					// Current handheld internal displays have issues
+					// with PQ, e.g., Ayaneo 3, Steam Deck etc.
+					// Use Gamma 2.2 as the safest option for now.
+					m_Mutable.HDR.eOutputEncodingEOTF = EOTF_Gamma22;
+				else
+					m_Mutable.HDR.eOutputEncodingEOTF = EOTF_PQ;
 				m_Mutable.HDR.uMaxContentLightLevel =
 					pHDRStaticMetadata->desired_content_max_luminance
 					? nits_to_u16( pHDRStaticMetadata->desired_content_max_luminance )
diff --git a/src/backend.h b/src/backend.h
index 18cb67f8c3f5..e488c335b371 100644
--- a/src/backend.h
+++ b/src/backend.h
@@ -23,6 +23,7 @@ struct wlr_dmabuf_attributes;
 struct FrameInfo_t;
 
 extern bool steamMode;
+extern bool disableInternalPq;
 
 namespace gamescope
 {
diff --git a/src/main.cpp b/src/main.cpp
index bdc9a5e0de3c..96bceab56ac7 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -144,6 +144,7 @@ const struct option *gamescope_options = (struct option[]){
 	{ "hdr-enabled", no_argument, nullptr, 0 },
 	{ "hdr-sdr-content-nits", required_argument, nullptr, 0 },
 	{ "hdr-itm-enabled", no_argument, nullptr, 0 },
+	{ "hdr-pq-internal-enable", no_argument, nullptr, 0 },
 	{ "hdr-itm-sdr-nits", required_argument, nullptr, 0 },
 	{ "hdr-itm-target-nits", required_argument, nullptr, 0 },
 	{ "hdr-debug-force-support", no_argument, nullptr, 0 },
@@ -211,6 +212,7 @@ const char usage[] =
 	"  --sdr-gamut-wideness           Set the 'wideness' of the gamut for SDR comment. 0 - 1.\n"
 	"  --hdr-sdr-content-nits         set the luminance of SDR content in nits. Default: 400 nits.\n"
 	"  --hdr-itm-enabled              enable SDR->HDR inverse tone mapping. only works for SDR input.\n"
+	"  --hdr-pq-internal-enable       enable PQ transform even on internal displays (e.g. Legion Go 2)\n"
 	"  --hdr-itm-sdr-nits             set the luminance of SDR content in nits used as the input for the inverse tone mapping process.\n"
 	"                                 Default: 100 nits, Max: 1000 nits\n"
 	"  --hdr-itm-target-nits          set the target luminace of the inverse tone mapping process.\n"
@@ -625,6 +627,7 @@ static bool IsInDebugSession()
 #endif
 
 bool steamMode = false;
+bool disableInternalPq = true;
 bool g_bLaunchMangoapp = false;
 
 static void UpdateCompatEnvVars()
diff --git a/src/steamcompmgr.cpp b/src/steamcompmgr.cpp
index 0fae5ac9fdb0..b09977cc6e47 100644
--- a/src/steamcompmgr.cpp
+++ b/src/steamcompmgr.cpp
@@ -155,6 +155,8 @@ gamescope_color_mgmt_luts g_ScreenshotColorMgmtLutsHDR[ EOTF_Count ];
 static lut1d_t g_tmpLut1d;
 static lut3d_t g_tmpLut3d;
 
+extern bool disableInternalPq;
+
 extern int g_nDynamicRefreshHz;
 
 bool g_bForceHDRSupportDebug = false;
@@ -8022,6 +8024,8 @@ steamcompmgr_main(int argc, char **argv)
 					g_bForceHDR10OutputDebug = true;
 				} else if (strcmp(opt_name, "hdr-itm-enabled") == 0 || strcmp(opt_name, "hdr-itm-enable") == 0) {
 					g_bHDRItmEnable = true;
+				} else if (strcmp(opt_name, "hdr-pq-internal-enable") == 0) {
+					disableInternalPq = false;
 				} else if (strcmp(opt_name, "sdr-gamut-wideness") == 0) {
 					g_ColorMgmt.pending.sdrGamutWideness = atof(optarg);
 				} else if (strcmp(opt_name, "hdr-sdr-content-nits") == 0) {
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <git@antheas.dev>
Date: Fri, 29 Aug 2025 17:17:06 +0200
Subject: chore: use system glm, stb

---
 meson.build | 6 ++----
 1 file changed, 2 insertions(+), 4 deletions(-)

diff --git a/meson.build b/meson.build
index 5e5bd4cdc7c4..802e4a052bcd 100644
--- a/meson.build
+++ b/meson.build
@@ -50,10 +50,8 @@ dep_x11 = dependency('x11')
 dep_wayland = dependency('wayland-client')
 vulkan_dep = dependency('vulkan')
 
-glm_proj = subproject('glm')
-glm_dep = glm_proj.get_variable('glm_dep')
-stb_proj = subproject('stb')
-stb_dep = stb_proj.get_variable('stb_dep')
+glm_dep = dependency('glm')
+stb_dep = dependency('stb')
 
 if get_option('enable_openvr_support')
   openvr_dep = dependency('openvr', version: '>= 2.7', required : false)
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <git@antheas.dev>
Date: Fri, 29 Aug 2025 19:04:17 +0200
Subject: Revert "mangoapp: plumb engineName"

This reverts commit b9f20436d1bdf7bd8212541817b254e1b4c8eb1e.
---
 layer/VkLayer_FROG_gamescope_wsi.cpp    | 9 +--------
 protocol/gamescope-swapchain.xml        | 1 -
 src/WaylandServer/WaylandServerLegacy.h | 1 -
 src/mangoapp.cpp                        | 6 ------
 src/steamcompmgr.cpp                    | 7 -------
 src/steamcompmgr.hpp                    | 1 -
 src/steamcompmgr_shared.hpp             | 2 --
 src/wlserver.cpp                        | 4 +---
 8 files changed, 2 insertions(+), 29 deletions(-)

diff --git a/layer/VkLayer_FROG_gamescope_wsi.cpp b/layer/VkLayer_FROG_gamescope_wsi.cpp
index 263cbc37bd88..d1835a4c7487 100644
--- a/layer/VkLayer_FROG_gamescope_wsi.cpp
+++ b/layer/VkLayer_FROG_gamescope_wsi.cpp
@@ -404,7 +404,6 @@ namespace GamescopeWSILayer {
   struct GamescopeInstanceData {
     wl_display* display;
     uint32_t appId = 0;
-    std::string engineName;
     GamescopeLayerClient::Flags flags = 0;
   };
   VKROOTS_DEFINE_SYNCHRONIZED_MAP_TYPE(GamescopeInstance, VkInstance);
@@ -631,14 +630,9 @@ namespace GamescopeWSILayer {
       {
         uint32_t appId = clientAppId();
 
-        std::string engineName;
-        if (pCreateInfo->pApplicationInfo && pCreateInfo->pApplicationInfo->pEngineName)
-          engineName = pCreateInfo->pApplicationInfo->pEngineName;
-
         auto state = GamescopeInstance::create(*pInstance, GamescopeInstanceData {
           .display = display,
           .appId   = appId,
-          .engineName = engineName,
           .flags   = defaultLayerClientFlags(pCreateInfo->pApplicationInfo, appId),
         });
 
@@ -1275,8 +1269,7 @@ namespace GamescopeWSILayer {
         uint32_t(pCreateInfo->imageColorSpace),
         uint32_t(pCreateInfo->compositeAlpha),
         uint32_t(pCreateInfo->preTransform),
-        uint32_t(pCreateInfo->clipped),
-        gamescopeInstance->engineName.c_str());
+        uint32_t(pCreateInfo->clipped));
 
       return VK_SUCCESS;
     }
diff --git a/protocol/gamescope-swapchain.xml b/protocol/gamescope-swapchain.xml
index 58ac8463b752..91be3fc02d67 100644
--- a/protocol/gamescope-swapchain.xml
+++ b/protocol/gamescope-swapchain.xml
@@ -89,7 +89,6 @@
       <arg name="vk_composite_alpha" type="uint" summary="VkCompositeAlphaFlagBitsKHR of swapchain"/>
       <arg name="vk_pre_transform" type="uint" summary="VkSurfaceTransformFlagBitsKHR of swapchain"/>
       <arg name="vk_clipped" type="uint" summary="clipped (VkBool32) of swapchain"/>
-      <arg name="vk_engine_name" type="string" summary="Engine name"/>
     </request>
 
     <request name="set_present_mode">
diff --git a/src/WaylandServer/WaylandServerLegacy.h b/src/WaylandServer/WaylandServerLegacy.h
index 63ee2ca17e8c..0facb7dc8b1e 100644
--- a/src/WaylandServer/WaylandServerLegacy.h
+++ b/src/WaylandServer/WaylandServerLegacy.h
@@ -29,7 +29,6 @@ struct wlserver_vk_swapchain_feedback
 	VkCompositeAlphaFlagBitsKHR vk_composite_alpha;
 	VkSurfaceTransformFlagBitsKHR vk_pre_transform;
 	VkBool32 vk_clipped;
-	std::shared_ptr<std::string> vk_engine_name;
 
 	std::shared_ptr<gamescope::BackendBlob> hdr_metadata_blob;
 };
diff --git a/src/mangoapp.cpp b/src/mangoapp.cpp
index d8e1ce7edafe..91e01bc275c6 100644
--- a/src/mangoapp.cpp
+++ b/src/mangoapp.cpp
@@ -31,7 +31,6 @@ struct mangoapp_msg_v1 {
     uint16_t displayRefresh;
     bool bAppWantsHDR : 1;
     bool bSteamFocused : 1;
-    char engineName[40];
     
     // WARNING: Always ADD fields, never remove or repurpose fields
 } __attribute__((packed)) mangoapp_msg_v1;
@@ -61,11 +60,6 @@ void mangoapp_update( uint64_t visible_frametime, uint64_t app_frametime_ns, uin
     mangoapp_msg_v1.displayRefresh = (uint16_t) gamescope::ConvertmHzToHz( g_nOutputRefresh );
     mangoapp_msg_v1.bAppWantsHDR = g_bAppWantsHDRCached;
     mangoapp_msg_v1.bSteamFocused = g_focusedBaseAppId == 769;
-    memset(mangoapp_msg_v1.engineName, 0, sizeof(mangoapp_msg_v1.engineName));
-    if (focusWindow_engine)
-        focusWindow_engine->copy(mangoapp_msg_v1.engineName, sizeof(mangoapp_msg_v1.engineName) / sizeof(char));
-    else
-        std::string("gamescope").copy(mangoapp_msg_v1.engineName, sizeof(mangoapp_msg_v1.engineName) / sizeof(char));
     msgsnd(msgid, &mangoapp_msg_v1, sizeof(mangoapp_msg_v1) - sizeof(mangoapp_msg_v1.hdr.msg_type), IPC_NOWAIT);
 }
 
diff --git a/src/steamcompmgr.cpp b/src/steamcompmgr.cpp
index b09977cc6e47..741745a26e85 100644
--- a/src/steamcompmgr.cpp
+++ b/src/steamcompmgr.cpp
@@ -1031,7 +1031,6 @@ int g_BlurRadius = 5;
 unsigned int g_BlurFadeStartTime = 0;
 
 pid_t focusWindow_pid, sdFocusWindow_pid;
-std::shared_ptr<std::string> focusWindow_engine = nullptr;
 
 focus_t g_steamcompmgr_xdg_focus;
 std::vector<std::shared_ptr<steamcompmgr_win_t>> g_steamcompmgr_xdg_wins;
@@ -6511,9 +6510,6 @@ bool handle_done_commit( steamcompmgr_win_t *w, xwayland_ctx_t *ctx, uint64_t co
 	uint32_t j;
 	for ( j = 0; j < w->commit_queue.size(); j++ )
 	{
-		if (w->commit_queue[ j ]->feedback.has_value())
-			w->engineName = w->commit_queue[ j ]->feedback->vk_engine_name;
-
 		if ( w->commit_queue[ j ]->commitID == commitID )
 		{
 			gpuvis_trace_printf( "commit %lu done", w->commit_queue[ j ]->commitID );
@@ -6564,9 +6560,6 @@ bool handle_done_commit( steamcompmgr_win_t *w, xwayland_ctx_t *ctx, uint64_t co
 					if ( !cv_paint_debug_pause_base_plane )
 						g_HeldCommits[ HELD_COMMIT_BASE ] = w->commit_queue[ j ];
 					hasRepaint = true;
-
-					focusWindow_engine = w->engineName;
-					focusWindow_pid = w->pid;
 				}
 
 				if ( w == pFocus->overrideWindow )
diff --git a/src/steamcompmgr.hpp b/src/steamcompmgr.hpp
index 98e927296483..2f489a26a0aa 100644
--- a/src/steamcompmgr.hpp
+++ b/src/steamcompmgr.hpp
@@ -144,7 +144,6 @@ struct wlserver_x11_surface_info *lookup_x11_surface_info_from_xid( gamescope_xw
 
 extern gamescope::VBlankTime g_SteamCompMgrVBlankTime;
 extern pid_t focusWindow_pid;
-extern std::shared_ptr<std::string> focusWindow_engine;
 
 void init_xwayland_ctx(uint32_t serverId, gamescope_xwayland_server_t *xwayland_server);
 void gamescope_set_selection(std::string contents, GamescopeSelection eSelection);
diff --git a/src/steamcompmgr_shared.hpp b/src/steamcompmgr_shared.hpp
index 5cb29733bb26..55a691fc6b8f 100644
--- a/src/steamcompmgr_shared.hpp
+++ b/src/steamcompmgr_shared.hpp
@@ -149,8 +149,6 @@ struct steamcompmgr_win_t {
 	bool unlockedForFrameCallback = false;
 	bool receivedDoneCommit = false;
 
-	std::shared_ptr<std::string> engineName;
-
 	std::vector< gamescope::Rc<commit_t> > commit_queue;
 	std::shared_ptr<std::vector< uint32_t >> icon;
 
diff --git a/src/wlserver.cpp b/src/wlserver.cpp
index 2747c7314e56..563effbaad77 100644
--- a/src/wlserver.cpp
+++ b/src/wlserver.cpp
@@ -901,8 +901,7 @@ static void gamescope_swapchain_swapchain_feedback( struct wl_client *client, st
 	uint32_t vk_colorspace,
 	uint32_t vk_composite_alpha,
 	uint32_t vk_pre_transform,
-	uint32_t vk_clipped,
-	const char *vk_engine_name)
+	uint32_t vk_clipped)
 {
 	wlserver_wl_surface_info *wl_info = (wlserver_wl_surface_info *)wl_resource_get_user_data( resource );
 	if ( wl_info )
@@ -914,7 +913,6 @@ static void gamescope_swapchain_swapchain_feedback( struct wl_client *client, st
 			.vk_composite_alpha = VkCompositeAlphaFlagBitsKHR(vk_composite_alpha),
 			.vk_pre_transform = VkSurfaceTransformFlagBitsKHR(vk_pre_transform),
 			.vk_clipped = VkBool32(vk_clipped),
-			.vk_engine_name = std::make_shared<std::string>(vk_engine_name),
 			.hdr_metadata_blob = nullptr,
 		});
 	}
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <git@antheas.dev>
Date: Sun, 31 Aug 2025 20:55:02 +0200
Subject: fix: separate blend tf to its own check

Currently, blend tf and other color mgmt checks are combined into one
check. However, new hardware does not support the blend tf for a plane,
causing loss of all color mgmt features. Separate the checks so that
color mgmt can still be used on such hardware.

Also, add the other function checks to drm_supports_color_mgmt so that
there are no edge cases where only subproperties are supported.
---
 src/Backends/DRMBackend.cpp | 40 +++++++++++++++++++++++++++++--------
 1 file changed, 32 insertions(+), 8 deletions(-)

diff --git a/src/Backends/DRMBackend.cpp b/src/Backends/DRMBackend.cpp
index b9b3fd160b75..0fb1deb4c8e4 100644
--- a/src/Backends/DRMBackend.cpp
+++ b/src/Backends/DRMBackend.cpp
@@ -559,6 +559,7 @@ extern std::string g_reshade_effect;
 
 bool drm_update_color_mgmt(struct drm_t *drm);
 bool drm_supports_color_mgmt(struct drm_t *drm);
+bool drm_supports_srgb_to_pq(struct drm_t *drm);
 bool drm_set_connector( struct drm_t *drm, gamescope::CDRMConnector *conn );
 
 struct drm_color_ctm2 {
@@ -2691,13 +2692,15 @@ drm_prepare_liftoff( struct drm_t *drm, const struct FrameInfo_t *frameInfo, boo
 				}
 			}
 
-			if ( drm_supports_color_mgmt( drm ) )
+			if  ( drm_supports_srgb_to_pq( drm ) )
 			{
 				if (!cv_drm_debug_disable_blend_tf && !bSinglePlane)
 					liftoff_layer_set_property( drm->lo_layers[ i ], "AMD_PLANE_BLEND_TF", drm->pending.output_tf );
 				else
-					liftoff_layer_set_property( drm->lo_layers[ i ], "AMD_PLANE_BLEND_TF", AMDGPU_TRANSFER_FUNCTION_DEFAULT );
-
+					liftoff_layer_set_property( drm->lo_layers[ i ], "AMD_PLANE_BLEND_TF", AMDGPU_TRANSFER_FUNCTION_DEFAULT );	
+			}
+			if ( drm_supports_color_mgmt( drm ) )
+			{
 				if (!cv_drm_debug_disable_ctm && frameInfo->layers[i].ctm != nullptr)
 					liftoff_layer_set_property( drm->lo_layers[ i ], "AMD_PLANE_CTM", frameInfo->layers[i].ctm->GetBlobValue() );
 				else
@@ -2712,13 +2715,16 @@ drm_prepare_liftoff( struct drm_t *drm, const struct FrameInfo_t *frameInfo, boo
 			liftoff_layer_unset_property( drm->lo_layers[ i ], "COLOR_ENCODING" );
 			liftoff_layer_unset_property( drm->lo_layers[ i ], "COLOR_RANGE" );
 
+			if ( drm_supports_srgb_to_pq( drm ) )
+			{
+				liftoff_layer_set_property( drm->lo_layers[ i ], "AMD_PLANE_BLEND_TF", AMDGPU_TRANSFER_FUNCTION_DEFAULT );
+			}
 			if ( drm_supports_color_mgmt( drm ) )
 			{
 				liftoff_layer_set_property( drm->lo_layers[ i ], "AMD_PLANE_DEGAMMA_TF", AMDGPU_TRANSFER_FUNCTION_DEFAULT );
 				liftoff_layer_set_property( drm->lo_layers[ i ], "AMD_PLANE_SHAPER_LUT", 0 );
 				liftoff_layer_set_property( drm->lo_layers[ i ], "AMD_PLANE_SHAPER_TF", 0 );
 				liftoff_layer_set_property( drm->lo_layers[ i ], "AMD_PLANE_LUT3D", 0 );
-				liftoff_layer_set_property( drm->lo_layers[ i ], "AMD_PLANE_BLEND_TF", AMDGPU_TRANSFER_FUNCTION_DEFAULT );
 				liftoff_layer_set_property( drm->lo_layers[ i ], "AMD_PLANE_CTM", 0 );
 			}
 		}
@@ -2870,7 +2876,7 @@ int drm_prepare( struct drm_t *drm, bool async, const struct FrameInfo_t *frameI
 
 	bool bSinglePlane = frameInfo->layerCount < 2 && cv_drm_single_plane_optimizations;
 
-	if ( drm_supports_color_mgmt( &g_DRM ) && frameInfo->applyOutputColorMgmt )
+	if ( drm_supports_srgb_to_pq( &g_DRM ) && frameInfo->applyOutputColorMgmt )
 	{
 		if ( !cv_drm_debug_disable_output_tf && !bSinglePlane )
 		{
@@ -3371,7 +3377,20 @@ bool drm_supports_color_mgmt(struct drm_t *drm)
 	if ( !drm->pPrimaryPlane )
 		return false;
 
-	return drm->pPrimaryPlane->GetProperties().AMD_PLANE_CTM.has_value() && drm->pPrimaryPlane->GetProperties().AMD_PLANE_BLEND_TF.has_value();
+	return drm->pPrimaryPlane->GetProperties().AMD_PLANE_CTM.has_value() &&         // dm->dc->caps.color.mpc.gamut_remap
+			drm->pPrimaryPlane->GetProperties().AMD_PLANE_SHAPER_LUT.has_value() && // dpp_color_caps.hw_3d_lut
+			drm->pPrimaryPlane->GetProperties().AMD_PLANE_DEGAMMA_TF.has_value();   // dpp_color_caps.dgam_ram || dpp_color_caps.gamma_corr
+}
+
+bool drm_supports_srgb_to_pq(struct drm_t *drm)
+{
+	if ( g_bForceDisableColorMgmt )
+		return false;
+
+	if ( !drm->pPrimaryPlane )
+		return false;
+
+	return drm->pPrimaryPlane->GetProperties().AMD_PLANE_BLEND_TF.has_value(); // dpp_color_caps.ogam_ram
 }
 
 std::span<const uint32_t> drm_get_valid_refresh_rates( struct drm_t *drm )
@@ -3501,12 +3520,12 @@ namespace gamescope
 			if ( g_bOutputHDREnabled )
 			{
 				bNeedsFullComposite |= g_bHDRItmEnable;
-				if ( !SupportsColorManagement() )
+				if ( !SupportsSRGBtoPQ() )
 					bNeedsFullComposite |= ( pFrameInfo->layerCount > 1 || pFrameInfo->layers[0].colorspace != GAMESCOPE_APP_TEXTURE_COLORSPACE_HDR10_PQ );
 			}
 			else
 			{
-				if ( !SupportsColorManagement() )
+				if ( !SupportsSRGBtoPQ() )
 					bNeedsFullComposite |= ColorspaceIsHDR( pFrameInfo->layers[0].colorspace );
 			}
 
@@ -3915,6 +3934,11 @@ namespace gamescope
 			return drm_supports_color_mgmt( &g_DRM );
 		}
 
+		bool SupportsSRGBtoPQ() const
+		{
+			return drm_supports_srgb_to_pq( &g_DRM );
+		}
+
 		int Commit( const FrameInfo_t *pFrameInfo )
 		{
 			drm_t *drm = &g_DRM;
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <git@antheas.dev>
Date: Sat, 8 Nov 2025 23:43:54 +0100
Subject: remove zotac zone config (too many panel variants)

---
 .../00-gamescope/displays/zotac.zone.oled.lua | 56 -------------------
 1 file changed, 56 deletions(-)
 delete mode 100644 scripts/00-gamescope/displays/zotac.zone.oled.lua

diff --git a/scripts/00-gamescope/displays/zotac.zone.oled.lua b/scripts/00-gamescope/displays/zotac.zone.oled.lua
deleted file mode 100644
index f800fc7eee6f..000000000000
--- a/scripts/00-gamescope/displays/zotac.zone.oled.lua
+++ /dev/null
@@ -1,56 +0,0 @@
--- colorimetry from DXQ7D0023 PDF specification
-local zotac_amoled_colorimetry = {
-   r = { x = 0.6396, y = 0.3300 },
-   g = { x = 0.2998, y = 0.5996 },
-   b = { x = 0.1503, y = 0.0595 },
-   w = { x = 0.3095, y = 0.3095 }
-}
-
-gamescope.config.known_displays.zotac_amoled = {
-    pretty_name = "DXQ7D0023 AMOLED",
-    dynamic_refresh_rates = {
-        60, 72, 90, 120
-    },
-    hdr = {
-        supported = true,
-        force_enabled = true,
-        eotf = gamescope.eotf.gamma22,
-        max_content_light_level = 993,
-        max_frame_average_luminance = 400,
-        min_content_light_level = 0.007
-    },
-    colorimetry = zotac_amoled_colorimetry,
-    dynamic_modegen = function(base_mode, refresh)
-        debug("Generating mode "..refresh.."Hz for DXQ7D0023 AMOLED")
-        local mode = base_mode
-
-        gamescope.modegen.set_resolution(mode, 1080, 1920)
-
-        -- Horizontal timings from PDF:       HFP, HSync, HBP
-        gamescope.modegen.set_h_timings(mode, 80, 44, 156)
-        -- Vertical timings from PDF: VFP=20, VSync=1, VBP=15
-        gamescope.modegen.set_v_timings(mode, 48, 2, 14)
-
-        mode.clock = gamescope.modegen.calc_max_clock(mode, refresh)
-        mode.vrefresh = gamescope.modegen.calc_vrefresh(mode)
-
-        return mode
-    end,
-    matches = function(display)
-        -- Match based on the EDID information
-        local lcd_types = {
-            { vendor = "ZDZ", model = "ZDZ0501" },
-            { vendor = "DXQ", model = "DXQ7D0023" },
-        }
-
-        for index, value in ipairs(lcd_types) do
-            if value.vendor == display.vendor and value.model == display.model then
-                debug("[zotac_amoled] Matched vendor: "..value.vendor.." model: "..value.model)
-                return 5000
-            end
-        end
-
-        return -1
-    end
-}
-debug("Registered DXQ7D0023 AMOLED as a known display")
-- 
2.51.2


From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Antheas Kapenekakis <git@antheas.dev>
Date: Sun, 9 Nov 2025 13:13:50 +0100
Subject: fix: enable HDR colorspace only when requested

Currently, when using a PQ HDR10 display, if the user enables HDR for
externals or always for internals, the output colorspace is always PQ,
which causes additional battery drain, brightness quirks, and can
potentially cause artifacting on Nvidia.

Move HDR advertisment to occur based on support. Then, instead of
enabling HDR always, detect when an app requests HDR and only enable it
afterwards. Retain HDR capability until the app switches to SDR or the
user exits it.
---
 src/steamcompmgr.cpp        | 79 +++++++++++++++++++++++++------------
 src/steamcompmgr_shared.hpp |  1 +
 2 files changed, 54 insertions(+), 26 deletions(-)

diff --git a/src/steamcompmgr.cpp b/src/steamcompmgr.cpp
index 741745a26e85..2accc28f085b 100644
--- a/src/steamcompmgr.cpp
+++ b/src/steamcompmgr.cpp
@@ -886,6 +886,7 @@ global_focus_t *GetCurrentFocus()
 
 uint32_t		currentOutputWidth, currentOutputHeight;
 bool			currentHDROutput = false;
+bool			currentHDRSupport = false;
 bool			currentHDRForce = false;
 
 std::vector< uint32_t > vecFocuscontrolAppIDs;
@@ -6750,6 +6751,8 @@ void handle_presented_for_window( steamcompmgr_win_t* w )
 			w->last_commit_present_time = lastCommit->present_time;
 		}
 
+		w->bHasHDRColorspace = ColorspaceIsHDR(lastCommit->colorspace());
+
 		if (!lastCommit->presentation_feedbacks.empty() || lastCommit->present_id)
 		{
 			if (!lastCommit->presentation_feedbacks.empty())
@@ -8362,15 +8365,62 @@ steamcompmgr_main(int argc, char **argv)
 
 		g_uCompositeDebug = cv_composite_debug;
 
-		g_bOutputHDREnabled = (g_bSupportsHDR_CachedValue || g_bForceHDR10OutputDebug) && cv_hdr_enabled;
+		// Advertise our HDR support state to X11 apps
+		bool hdr_supported = (g_bSupportsHDR_CachedValue || g_bForceHDR10OutputDebug) && cv_hdr_enabled;
+		if ( currentHDRSupport != hdr_supported ||
+			 currentHDRForce != g_bForceHDRSupportDebug ) {
+			gamescope_xwayland_server_t *server = NULL;
+			for (size_t i = 0; (server = wlserver_get_xwayland_server(i)); i++)
+			{
+				uint32_t hdr_value = ( hdr_supported || g_bForceHDRSupportDebug ) ? 1 : 0;
+				XChangeProperty(server->ctx->dpy, server->ctx->root, server->ctx->atoms.gamescopeHDROutputFeedback, XA_CARDINAL, 32, PropModeReplace,
+					(unsigned char *)&hdr_value, 1 );
+
+				server->ctx->cursor->setDirty();
+
+				if (server->ctx.get() == root_ctx)
+				{
+					flush_root = true;
+				}
+				else
+				{
+					XFlush(server->ctx->dpy);
+				}
+			}
+
+			currentHDRSupport = hdr_supported;
+			currentHDRForce = g_bForceHDRSupportDebug;
+		}
+
+		// Check if any running app has requested an hdr colorspace
+		// and only if it has, enable hdr output
+		bool hdr_requested = false;
+		{
+			gamescope_xwayland_server_t *server = NULL;
+			for (size_t i = 0; (server = wlserver_get_xwayland_server(i)); i++)
+			{
+				for (steamcompmgr_win_t *w = server->ctx->list; w; w = w->xwayland().next)
+				{
+					if (w->bHasHDRColorspace)
+						hdr_requested = true;
+				}
+			}
+
+			for ( const auto& xdg_win : g_steamcompmgr_xdg_wins )
+			{
+				if (xdg_win->bHasHDRColorspace)
+					hdr_requested = true;
+			}
+		}
+		g_bOutputHDREnabled = hdr_supported &&
+			(hdr_requested || GetBackend()->GetCurrentConnector()->GetScreenType() != gamescope::GAMESCOPE_SCREEN_TYPE_INTERNAL);
 
 		// Pick our width/height for this potential frame, regardless of how it might change later
 		// At some point we might even add proper locking so we get real updates atomically instead
 		// of whatever jumble of races the below might cause over a couple of frames
 		if ( currentOutputWidth != g_nOutputWidth ||
 			 currentOutputHeight != g_nOutputHeight ||
-			 currentHDROutput != g_bOutputHDREnabled ||
-			 currentHDRForce != g_bForceHDRSupportDebug )
+			 currentHDROutput != g_bOutputHDREnabled )
 		{
 			if ( steamMode && g_nXWaylandCount > 1 )
 			{
@@ -8394,32 +8444,9 @@ steamcompmgr_main(int argc, char **argv)
 				vulkan_remake_output_images();
 			}
 
-
-			{
-				gamescope_xwayland_server_t *server = NULL;
-				for (size_t i = 0; (server = wlserver_get_xwayland_server(i)); i++)
-				{
-					uint32_t hdr_value = ( g_bOutputHDREnabled || g_bForceHDRSupportDebug ) ? 1 : 0;
-					XChangeProperty(server->ctx->dpy, server->ctx->root, server->ctx->atoms.gamescopeHDROutputFeedback, XA_CARDINAL, 32, PropModeReplace,
-						(unsigned char *)&hdr_value, 1 );
-
-					server->ctx->cursor->setDirty();
-
-					if (server->ctx.get() == root_ctx)
-					{
-						flush_root = true;
-					}
-					else
-					{
-						XFlush(server->ctx->dpy);
-					}
-				}
-			}
-
 			currentOutputWidth = g_nOutputWidth;
 			currentOutputHeight = g_nOutputHeight;
 			currentHDROutput = g_bOutputHDREnabled;
-			currentHDRForce = g_bForceHDRSupportDebug;
 
 #if HAVE_PIPEWIRE
 			nudge_pipewire();
diff --git a/src/steamcompmgr_shared.hpp b/src/steamcompmgr_shared.hpp
index 55a691fc6b8f..0b5efe2b6258 100644
--- a/src/steamcompmgr_shared.hpp
+++ b/src/steamcompmgr_shared.hpp
@@ -142,6 +142,7 @@ struct steamcompmgr_win_t {
 	uint32_t hwndStyleEx = 0;
 
 	bool bHasHadNonSRGBColorSpace = false;
+	bool bHasHDRColorspace = false;
 
 	bool nudged = false;
 	bool ignoreOverrideRedirect = false;
-- 
2.51.2

