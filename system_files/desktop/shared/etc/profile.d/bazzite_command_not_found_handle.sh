command_not_found_handle() {
    {
        local \
            cmd \
            message \
            max_lines=4 \
            completions \
            suggestions \
            ujust_completions \
            commands_completions \
            ;

        cmd="$1${2:+ $2}" # We include $2 because of ujust <recipe_name>

        # Obtain the list of ujust commands.
        read -d '' -r ujust_completions < <(ujust --dump-format=json --dump 2>/dev/null |
            # jq -r '.recipes | to_entries | map("ujust \(.key)\(if .value.doc then "s # \(.value.doc)" else "" end)") | .[]' | # Alternative version with documentation
            jq -r '.recipes | to_entries | map(select(.key | startswith("_") | not) | "ujust \(.key)") | .[]' |
            sort -u)

        read -d '' -r commands_completions < <(compgen -c 2>/dev/null | grep -v '^_' | grep . | sort -u)

        # Merge all the completions
        printf -v completions '%s\n' "$ujust_completions" "$commands_completions"

        # Store an array of suggestions generated by fuzzy search,
        readarray -t suggestions <<<"$(echo "$completions" | fzf --no-extended -i --filter="$cmd" -0 2>/dev/null | head -n $max_lines)"

        if [[ ${#suggestions[@]} -eq 0 || ${suggestions[0]} == "" ]]; then
            printf >&2 '%s\n' "command not found: $1${2:+ $2}"
            return 127
        fi

        { message="$(</dev/stdin)"; } <<EOF
command not found: $1
Maybe you meant one of the following:
$(printf -- '  - %s\n' "${suggestions[@]}")
EOF

        printf >&2 '%s\n' "$message"
        return 127
    } >&2
}
